;	Static Name Aliases
;
	TITLE   .\src\scsi.c
	.8087
INCLUDELIB	LLIBCE
MAINSEG	SEGMENT  WORD PUBLIC 'CODE'
MAINSEG	ENDS
_DATA	SEGMENT  WORD PUBLIC 'DATA'
_DATA	ENDS
CONST	SEGMENT  WORD PUBLIC 'CONST'
CONST	ENDS
_BSS	SEGMENT  WORD PUBLIC 'BSS'
_BSS	ENDS
DGROUP	GROUP	CONST, _BSS, _DATA
	ASSUME DS: DGROUP
	ASSUME  SS: NOTHING
PUBLIC  _scsi_name
EXTRN	DOSOPEN:FAR
EXTRN	_virt_to_lin:FAR
EXTRN	_lin_to_pages:FAR
EXTRN	_get_phys_addr:FAR
EXTRN	_phys_to_gdt:FAR
EXTRN	_get_gdt_slots:FAR
EXTRN	_dev_help:FAR
EXTRN	_alloc_req:FAR
EXTRN	_free_req:FAR
EXTRN	_unlock:FAR
EXTRN	_lock:FAR
EXTRN	_call_idc:FAR
EXTRN	_delete_devh:FAR
EXTRN	_set_new_devh:FAR
EXTRN	_get_avail_devh:FAR
_BSS      SEGMENT
COMM NEAR	_scsi_idc:	BYTE:	 12
COMM NEAR	_idc_entry:	BYTE:	 4
COMM NEAR	_handle:	BYTE:	 2
COMM NEAR	_gdt_selector:	 2:	 4
_BSS      ENDS
_DATA      SEGMENT
_scsi_name	DB	'SCSI-02$',  00H
_DATA      ENDS
MAINSEG      SEGMENT
	ASSUME	CS: MAINSEG
;|*** /****************************************************************************/
; Line 1
;|*** /* Routines for interfacing to the SCSI DD                                  */
;|*** /* The functions in this file are the heart of GENSCSI.SYS.  These are the  */
;|*** /* routines that interface to OS2SCSI.DMD.                                  */
;|*** /****************************************************************************/
;|*** /*                                                                          */
;|*** /* A general note - neither of the functions called by an application -     */
;|*** /* call_scsi() and transfer_scb() verify access to the buffers.  This can   */
;|*** /* cause kernel crashes of the application passes a bogus pointer.  It is   */
;|*** /* left as an exercise for the student to put buffer verification in.       */
;|*** /*                                                                          */
;|*** /****************************************************************************/
;|*** /* scsi_init()                                                              */
;|*** /*                                                                          */
;|*** /* This function does all the things that are needed at INIT time.  They    */
;|*** /* are:                                                                     */
;|*** /*                                                                          */
;|*** /* 1.  Allocate 4 GDT selectors for use when calling OS2SCSI.DMD            */
;|*** /*                                                                          */
;|*** /* 2.  Get the IDC addresses of OS2SCSI.DMD.  It does this via the AttachDD */
;|*** /*     Device Helper function.                                              */
;|*** /*                                                                          */
;|*** /* 3.  Get a file handle for OS2SCSI.  It does this via DosOpen.  This      */
;|*** /*     gives us a valid handle to put in the request packets we send to     */
;|*** /*     OS2SCSI.                                                             */
;|*** /*                                                                          */
;|*** /* If any of these steps fail, we return with a General Failure indication. */
;|*** /* Otherwise, we return success.                                            */
;|*** /*                                                                          */
;|*** /****************************************************************************/
;|*** /*                                                                          */
;|*** /* call_scsi()                                                              */
;|*** /*                                                                          */
;|*** /* This function handles all the calls to OS2SCSI except the Transfer SCB   */
;|*** /* commands.  Since these require a bit more processing, they are handled   */
;|*** /* separately.                                                              */
;|*** /*                                                                          */
;|*** /* The basic idea here is to build a new request packet with GDT based      */
;|*** /* pointers where the request packet from the application has LDT based     */
;|*** /* pointers.  The reason for the LDT to GDT switch is that OS2SCSI may have */
;|*** /* to access the buffer pointed to at INIT time and any LDT based pointer   */
;|*** /* will be invalid.  After the packet is built, it is given to OS2SCSI.     */
;|*** /* When OS2SCSI returns, the results are stored in the application's        */
;|*** /* request packet as if OS2SCSI put them there and we exit.                 */
;|*** /*                                                                          */
;|*** /* The actual steps taken are:                                              */
;|*** /* 1. Make sure it is a valid request.  If the category isn't 0x80, fail it */
;|*** /*    right here; there is no sense passing it to OS2SCSI.                  */
;|*** /*                                                                          */
;|*** /* 2. If it is Transfer SCB, call the Transfer SCB handler.                 */
;|*** /*                                                                          */
;|*** /* 3. If it is Allocate Device, make sure we have room in the open array to */
;|*** /*    store the resulting handle.  If we don't, return with an appropriate  */
;|*** /*    error code.                                                           */
;|*** /*                                                                          */
;|*** /* 4. Allocate a request packet, returning an error if it fails             */
;|*** /*                                                                          */
;|*** /* 5. Copy all the parameters except the parm buffer pointer, the data      */
;|*** /*    buffer pointer and the system file handle from the application's      */
;|*** /*    request packet to the newly created request packet.                   */
;|*** /*                                                                          */
;|*** /* 6. Create an GDT based pointer to the buffer pointed to by the parm      */
;|*** /*    buffer pointer in the application's request packet.  This is done     */
;|*** /*    by first getting the physical address of the buffer and then doing    */
;|*** /*    a PhysToGDT devhelper call with the passed length as the length of    */
;|*** /*    the new selector.  This pointer is stored in the Parm Buffer Pointer  */
;|*** /*    of the new request packet.                                            */
;|*** /*                                                                          */
;|*** /* 7. Do the same thing with the Data buffer pointer, using a different GDT */
;|*** /*    selector.                                                             */
;|*** /*                                                                          */
;|*** /* 8. Store the file handle we got from the DOsOpen at INIT time in the     */
;|*** /*    new request packet.                                                   */
;|*** /*                                                                          */
;|*** /* 9. Lock the parm and data buffers.                                       */
;|*** /*                                                                          */
;|*** /* 10. Call OS2SCSI with the new request packet.                            */
;|*** /*                                                                          */
;|*** /* 10. When we return from SO2SCSI, copy the following 3 values from the    */
;|*** /*    new request packet to the application's request packet:               */
;|*** /*    1. The request packet status.                                         */
;|*** /*    2. The parm buffer length                                             */
;|*** /*    3. The data buffer length                                             */
;|*** /*                                                                          */
;|*** /* 11. Free the allocated request packet                                    */
;|*** /*                                                                          */
;|*** /* 12. If the request succeeded and it was an Allocate Device, add the new  */
;|*** /*    device handle to the open array.  If it was a Deallocate device, take */
;|*** /*    the device handle from the open array.                                */
;|*** /*                                                                          */
;|*** /* 13. Unlock the parm and data buffers.                                    */
;|*** /*                                                                          */
;|*** /* 14. Return back to OS/2.                                                 */
;|*** /*                                                                          */
;|*** /****************************************************************************/
;|*** /*                                                                          */
;|*** /* transfer_scb()                                                           */
;|*** /*                                                                          */
;|*** /* This function is very similar to call_scsi(), except it has a bit more   */
;|*** /* processing to do on converting pointers.  First, the data buffer and     */
;|*** /* parm buffer pointers are handled just like in the regular call.  Next    */
;|*** /* comes the SCB Chain Header pointer.                                      */
;|*** /*                                                                          */
;|*** /* Inside the Transfer SCB block (pointed to by the parm buffer) are 2      */
;|*** /* pointers - a virtual pointer to the SCB Chain header and a physical      */
;|*** /* pointer to the first SCB in the chain.  (see the OEMBASE.TXT file for    */
;|*** /* more detail).  The virtual pointer must be changed from an LDT based     */
;|*** /* pointer to a GDT based pointer; the usual tricks are done.  In addition, */
;|*** /* however, we save away the original virtual pointer so we can replace it  */
;|*** /* in the Transfer SCB block when we are done.  This way, the caller can    */
;|*** /* continue to use the same block without modification.  Then, we store the */
;|*** /* physical address of the first SCB in the Transfer SCB block.             */
;|*** /*                                                                          */
;|*** /* Next comes the pointers in the SCB Header.  There is one here - the LDT  */
;|*** /* based pointer to the TSB.  The usual Lock/get physical address/save LDT  */
;|*** /* based pointer/make GDT based pointer steps are done.                     */
;|*** /*                                                                          */
;|*** /* The last to have this treatment is the System Buffer within the SCB.     */
;|*** /* For more detail about SCBs, see the IBM Microchannel SCSI Adapter Tech   */
;|*** /* Reference or the document within this package.  We need to store the     */
;|*** /* physical address here, not a virtual pointer.  This is because the IBM   */
;|*** /* SCSI adapter is a bus master and uses that address as the target for     */
;|*** /* DMA.                                                                     */
;|*** /*                                                                          */
;|*** /* Finally, we need to deal with Scatter/Gather.  Since OS/2 V2 uses a      */
;|*** /* paging system, the data buffer may consist of physical pages scattered   */
;|*** /* all over.  We need to indicate that to OS2SCSI.  To do that, we convert  */
;|*** /* the original virtual address of the system buffer in the SCB to a page   */
;|*** /* list.  This is a 2 step process as the only DevHelper function to create */
;|*** /* a page list requires a linear address as input, so we have to convert    */
;|*** /* the Virtual address to a linear address first.  Next, we see if the      */
;|*** /* buffer has more than 1 block of pages.  If it doesn't, we can leave the  */
;|*** /* GDT based pointer in place.  If not, we must replace it with the page    */
;|*** /* list and indicate in the SCB Enable word that the system buffer address  */
;|*** /* is a page list, not a GDT based pointer.                                 */
;|*** /*                                                                          */
;|*** /* From here on out, it's the same as the normal call SCSI, except for the  */
;|*** /* replacement of the original virtual addresses and more unlocks.          */
;|*** /*                                                                          */
;|*** /****************************************************************************/
;|*** /*                                                                          */
;|*** /* free_dhand()                                                             */
;|*** /*                                                                          */
;|*** /* This function calls OS2SCSI to deallocaet a device handle.  It is used   */
;|*** /* when we get a close on a file handle that has at least 1 device handle   */
;|*** /* still allocated.  This can happen if the application ends without doing  */
;|*** /* the deallocate or maybe it crashed.  No matter why it happened, we need  */
;|*** /* to explicitly free the devices it owns so other programs can reserve     */
;|*** /* them.                                                                    */
;|*** /*                                                                          */
;|*** /* The operation is failry simple - a Deallocate request packet is built    */
;|*** /* and sent to OS2SCSId handle to put in the request packets we send to     */
;|*** /* OS2SCSI.  After OS2SCSI returns, we free the request packet and return   */
;|*** /* to the caller.                                                           */
;|*** /*                                                                          */
;|*** /****************************************************************************/
;|*** #define INCL_DOSDEVICES
;|*** #define INCL_DOSMISC
;|*** #include <os2.h>
; Line 159
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: OS2.H
;|*** *
;|*** * This is the top level include file that includes all the files necessary
;|*** * for writing an OS/2 application.
;|*** *
;|*** * Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define OS2_INCLUDED
;|*** 
;|*** /* Common definitions */
;|*** 
;|*** #ifndef OS2DEF_INCLUDED 	/* Only include it once */
;|*** #include <os2def.h>
; Line 17
;|*** #endif
;|*** 
;|*** /* OS/2 Base Include File */
;|*** 
;|*** #include <bse.h>
; Line 22
;|*** /***************************************************************************\
;|*** *
;|*** * Module Name: BSE.H
;|*** *
;|*** * This file includes the definitions necessary for writing Base OS/2
;|*** * applications.
;|*** *
;|*** * Copyright (c) 1987-1990, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** * ===========================================================================
;|*** *
;|*** * The following symbols are used in this file for conditional sections.
;|*** *
;|*** *   INCL_BASE	-  ALL of OS/2 Base
;|*** *   INCL_DOS	-  OS/2 DOS Kernel
;|*** *   INCL_SUB	-  OS/2 VIO/KBD/MOU
;|*** *   INCL_DOSERRORS -  OS/2 Errors       - only included if symbol defined
;|*** *   INCL_DOSDEVIOCTL - Structures and constants for DosDevIOCtl
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define INCL_BASEINCLUDED
;|*** 
;|*** /* if INCL_BASE defined then define all the symbols */
;|*** #ifdef INCL_BASE
;|***     #define INCL_DOS
;|***     #define INCL_SUB
;|***     #define INCL_DOSERRORS
;|***     #define INCL_DOSDEVICES
;|***     #define INCL_DOSDEVIOCTL
;|*** #endif /* INCL_BASE */
;|*** 
;|*** #include <bsedos.h>	/* Base definitions		*/
; Line 33
;|*** 
;|*** #ifndef BSESUB_INCLUDED /* Only include it once 	*/
;|*** #include <bsesub.h>	/* VIO/KBD/MOU definitions	*/
; Line 36
;|*** #endif
;|*** 
;|*** #ifndef BSEERR_INCLUDED /* Only include it once 	*/
;|*** #include <bseerr.h>	/* Base error code definitions	*/
; Line 40
;|*** #endif
;|*** 
;|*** #if (defined(INCL_DOSDEVICES) || defined(INCL_DOSDEVIOCTL))
;|*** #ifndef BSEDEV_INCLUDED /* Only include it once 	*/
;|*** #include <bsedev.h>	/* IOCtls			*/
; Line 45
;|*** 
;|*** /* OS/2 Presentation Manager Include File */
;|*** 
;|*** #ifndef INCL_NOPM
;|*** #include <pm.h>
; Line 27
;|*** /****************************** Module Header ******************************\
;|*** *
;|*** * Module Name: PM.H
;|*** *
;|*** * This is the top level include file for Presentation Manager
;|*** *
;|*** * Copyright (c) 1989-1990, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** * =======================================================================
;|*** * The following symbols are used in this file for conditional sections.
;|*** *
;|*** *   INCL_PM		  -  ALL of OS/2 Presentation Manager
;|*** *   INCL_WIN		  -  OS/2 Window Manager
;|*** *   INCL_GPI		  -  OS/2 GPI
;|*** *   INCL_DEV		  -  OS/2 Device Support
;|*** *   INCL_AVIO		  -  OS/2 Advanced VIO
;|*** *   INCL_SPL		  -  OS/2 Spooler
;|*** *   INCL_PIC		  -  OS/2 Picture utilities
;|*** *   INCL_ORDERS 	  -  OS/2 Graphical Order Formats
;|*** *   INCL_BITMAPFILEFORMAT -  OS/2 Bitmap File Format
;|*** *   INCL_FONTFILEFORMAT   -  OS/2 Font File Format
;|*** *   INCL_ERRORS 	  -  OS/2 Errors
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** /* if INCL_PM defined then define all the symbols */
;|*** #ifdef INCL_PM
;|***     #define INCL_WIN
;|***     #define INCL_GPI
;|***     #define INCL_DEV
;|***     #define INCL_AVIO
;|***     #define INCL_SPL
;|***     #define INCL_PIC
;|***     #define INCL_ORDERS
;|***     #define INCL_BITMAPFILEFORMAT
;|***     #define INCL_FONTFILEFORMAT
;|***     #define INCL_ERRORS
;|*** #endif /* INCL_PM */
;|*** 
;|*** #include <pmwin.h>	/* OS/2 Window Manager definitions    */
; Line 40
;|*** /***************************************************************************\
;|*** *
;|*** * Module Name: PMWIN.H
;|*** *
;|*** * OS/2 Presentation Manager Window Manager include file
;|*** *
;|*** * Copyright (c) 1989-1990, Microsoft Corporation.  All rights reserved.
;|*** *
;|*** * =======================================================================
;|*** *
;|*** * The folowing symbols are used in this file for conditional sections.
;|*** *
;|*** * If INCL_WIN is defined, all subcomponents are included.
;|*** *
;|*** * Subcomponents marked with "+" are partially included by default:
;|*** *
;|*** *   #define:		    To include:
;|*** *
;|*** * + INCL_WINWINDOWMGR	    General window management
;|*** * + INCL_WINMESSAGEMGR	    Message management
;|*** * + INCL_WININPUT	    Mouse and keyboard input
;|*** * + INCL_WINDIALOGS	    Dialog boxes
;|*** * + INCL_WINSTATICS	    Static controls
;|*** * + INCL_WINBUTTONS	    Button controls
;|*** * + INCL_WINENTRYFIELDS     Entry Fields
;|*** *   INCL_WINMLE 	    Multiple Line Entry Fields
;|*** * + INCL_WINLISTBOXES	    List box controls
;|*** * + INCL_WINMENUS	    Menu controls
;|*** * + INCL_WINSCROLLBARS	    Scroll bar controls
;|*** * + INCL_WINFRAMEMGR	    Frame manager
;|*** *   INCL_WINFRAMECTLS	    Frame controls (title bars & size border)
;|*** *   INCL_WINRECTANGLES	    Rectangle routines
;|*** *   INCL_WINSYS 	    System values (and colors)
;|*** *   INCL_WINTIMER	    Timer routines
;|*** * + INCL_WINACCELERATORS    Keyboard accelerators
;|*** *   INCL_WINTRACKRECT	    WinTrackRect() function
;|*** *   INCL_WINCLIPBOARD	    Clipboard manager
;|*** * + INCL_WINCURSORS	    Text cursors
;|*** * + INCL_WINPOINTERS	    Mouse pointers
;|*** *   INCL_WINHOOKS	    Hook manager
;|*** * + INCL_WINSWITCHLIST	    Shell Switch List API
;|*** *   INCL_WINPROGRAMLIST     Shell Program List API
;|*** *   INCL_WINSHELLDATA	    Shell Data (?)
;|*** *   INCL_WINCOUNTRY	    Country support
;|*** *   INCL_WINHEAP	    Heap Manager
;|*** *   INCL_WINATOM	    Atom Manager
;|*** *   INCL_WINCATCHTHROW	    WinCatch/WinThrow support
;|*** *   INCL_WINERRORS	    Error code definitions
;|*** *   INCL_NLS		    DBCS window manager definition
;|*** * + INCL_WINHELP	    Help Manager definitions
;|*** *   INCL_WINLOAD	    Load/Delete Library/Procedure
;|*** *   INCL_WINTYPES	    Definitions for Datatypes
;|*** *
;|*** \***************************************************************************/
;|*** 
;|*** #define INCL_WININCLUDED
;|*** 
;|*** 
;|*** #ifdef INCL_WIN
;|*** 
;|*** #define INCL_WINWINDOWMGR
;|*** #define INCL_WINMESSAGEMGR
;|*** #define INCL_WININPUT
;|*** #define INCL_WINDIALOGS
;|*** #define INCL_WINSTATICS
;|*** #define INCL_WINBUTTONS
;|*** #define INCL_WINENTRYFIELDS
;|*** #define INCL_WINMLE
;|*** #define INCL_WINLISTBOXES
;|*** #define INCL_WINMENUS
;|*** #define INCL_WINSCROLLBARS
;|*** #define INCL_WINFRAMEMGR
;|*** #define INCL_WINFRAMECTLS
;|*** #define INCL_WINRECTANGLES
;|*** #define INCL_WINSYS
;|*** #define INCL_WINTIMER
;|*** #define INCL_WINACCELERATORS
;|*** #define INCL_WINTRACKRECT
;|*** #define INCL_WINCLIPBOARD
;|*** #define INCL_WINCURSORS
;|*** #define INCL_WINPOINTERS
;|*** #define INCL_WINHOOKS
;|*** #define INCL_WINSWITCHLIST
;|*** #define INCL_WINPROGRAMLIST
;|*** #define INCL_WINSHELLDATA
;|*** #define INCL_WINCOUNTRY
;|*** #define INCL_WINHEAP
;|*** #define INCL_WINATOM
;|*** #define INCL_WINCATCHTHROW
;|*** #define INCL_WINERRORS
;|*** #define INCL_WINDDE
;|*** #define INCL_WINHELP
;|*** #define INCL_WINLOAD
;|*** #define INCL_WINTYPES
;|*** 
;|*** #else /* INCL_WIN */
;|*** 
;|*** #ifdef RC_INVOKED
;|*** #define INCL_WININPUT
;|*** #define INCL_WINDIALOGS
;|*** #define INCL_WINSTATICS
;|*** #define INCL_WINBUTTONS
;|*** #define INCL_WINENTRYFIELDS
;|*** #define INCL_WINLISTBOXES
;|*** #define INCL_WINMENUS
;|*** #define INCL_WINSCROLLBARS
;|*** #define INCL_WINFRAMEMGR
;|*** #define INCL_WINFRAMECTLS
;|*** #define INCL_WINACCELERATORS
;|*** #define INCL_WINPOINTERS
;|*** #define INCL_WINMESSAGEMGR
;|*** #define INCL_WINMLE
;|*** #define INCL_WINHELP
;|*** #endif /* RC_INVOKED */
;|*** 
;|*** #endif /* INCL_WIN */
;|*** 
;|*** /* ensure standard entry field defintions if MLE is defined */
;|*** #ifdef INCL_WINMLE
;|*** #ifndef INCL_WINENTRYFIELDS
;|*** #define INCL_WINENTRYFIELDS
;|*** #endif /* INCL_WINENTRYFIELDS */
;|*** #endif /* INCL_WINMLE */
;|*** 
;|*** /* INCL_WINCOMMON compatability */
;|*** #ifdef INCL_WINCOMMON
;|*** #define INCL_WINWINDOWMGR
;|*** #endif /* INCL_WINCOMMON */
;|*** 
;|*** #ifdef INCL_ERRORS
;|*** #define INCL_WINERRORS
;|*** #endif  /* INCL_ERRORS */
;|*** 
;|*** /***************************************************************************/
;|*** /***	    General Window Management types, constants and macros	 ***/
;|*** 
;|*** #ifndef WIN_COMMON_INCLUDED
;|*** #define WIN_COMMON_INCLUDED
;|*** 
;|*** typedef VOID FAR *MPARAM;	/* mp	 */
;|*** typedef MPARAM FAR *PMPARAM;	/* pmp	 */
;|*** typedef VOID FAR *MRESULT;	/* mres  */
;|*** typedef MRESULT FAR *PMRESULT;	/* pmres */
;|*** 
;|*** /* Macros to make an MPARAM from standard types. */
;|*** #define MPFROMP(p)		   ((MPARAM)(VOID FAR *)(p))
;|*** #define MPFROMHWND(hwnd)	   ((MPARAM)(HWND)(hwnd))
;|*** #define MPFROMCHAR(ch)		   ((MPARAM)(USHORT)(ch))
;|*** #define MPFROMSHORT(s)		   ((MPARAM)(USHORT)(s))
;|*** #define MPFROM2SHORT(s1, s2)	   ((MPARAM)MAKELONG(s1, s2))
;|*** #define MPFROMSH2CH(s, uch1, uch2) ((MPARAM)MAKELONG(s, MAKESHORT(uch1, uch2)))
;|*** #define MPFROMLONG(l)		   ((MPARAM)(ULONG)(l))
;|*** 
;|*** /* Macros to extract standard types from an MPARAM */
;|*** #define PVOIDFROMMP(mp) 	((VOID FAR *)(mp))
;|*** #define HWNDFROMMP(mp)		((HWND)(mp))
;|*** #define CHAR1FROMMP(mp) 	((UCHAR)(mp))
;|*** #define CHAR2FROMMP(mp) 	((UCHAR)((ULONG)mp >> 8))
;|*** #define CHAR3FROMMP(mp) 	((UCHAR)((ULONG)mp >> 16))
;|*** #define CHAR4FROMMP(mp) 	((UCHAR)((ULONG)mp >> 24))
;|*** #define SHORT1FROMMP(mp)	((USHORT)(ULONG)(mp))
;|*** #define SHORT2FROMMP(mp)	((USHORT)((ULONG)mp >> 16))
;|*** #define LONGFROMMP(mp)		((ULONG)(mp))
;|*** 
;|*** /* Macros to make an MRESULT from standard types. */
;|*** #define MRFROMP(p)		((MRESULT)(VOID FAR *)(p))
;|*** #define MRFROMSHORT(s)		((MRESULT)(USHORT)(s))
;|*** #define MRFROM2SHORT(s1, s2)	((MRESULT)MAKELONG(s1, s2))
;|*** #define MRFROMLONG(l)		((MRESULT)(ULONG)(l))
;|*** 
;|*** /* Macros to extract standard types from an MRESULT */
;|*** #define PVOIDFROMMR(mr) 	((VOID FAR *)(mr))
;|*** #define SHORT1FROMMR(mr)	((USHORT)((ULONG)mr))
;|*** #define SHORT2FROMMR(mr)	((USHORT)((ULONG)mr >> 16))
;|*** #define LONGFROMMR(mr)		((ULONG)(mr))
;|*** 
;|*** typedef MRESULT (EXPENTRY *PFNWP)(HWND, USHORT, MPARAM, MPARAM);
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define HWND_DESKTOP		(HWND)1
;|*** #define HWND_OBJECT		(HWND)2
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define HWND_TOP		(HWND)3
;|*** #define HWND_BOTTOM		(HWND)4
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define HWND_THREADCAPTURE	(HWND)5
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** 
;|*** /* Standard Window Styles */
;|*** 
;|*** #define WS_VISIBLE		0x80000000L
;|*** #define WS_DISABLED		0x40000000L
;|*** #define WS_CLIPCHILDREN 	0x20000000L
;|*** #define WS_CLIPSIBLINGS 	0x10000000L
;|*** #define WS_PARENTCLIP		0x08000000L
;|*** #define WS_SAVEBITS		0x04000000L
;|*** #define WS_SYNCPAINT		0x02000000L
;|*** #define WS_MINIMIZED		0x01000000L
;|*** #define WS_MAXIMIZED		0x00800000L
;|*** 
;|*** /* Dialog manager styles */
;|*** 
;|*** #define WS_GROUP		0x00010000L
;|*** #define WS_TABSTOP		0x00020000L
;|*** #define WS_MULTISELECT		0x00040000L
;|*** 
;|*** 
;|*** /* Class styles */
;|*** 
;|*** #define CS_MOVENOTIFY		0x00000001L
;|*** #define CS_SIZEREDRAW		0x00000004L
;|*** #define CS_HITTEST		0x00000008L
;|*** #define CS_PUBLIC		0x00000010L
;|*** #define CS_FRAME		0x00000020L
;|*** #define CS_CLIPCHILDREN 	0x20000000L
;|*** #define CS_CLIPSIBLINGS 	0x10000000L
;|*** #define CS_PARENTCLIP		0x08000000L
;|*** #define CS_SAVEBITS		0x04000000L
;|*** #define CS_SYNCPAINT		0x02000000L
;|*** 
;|*** #endif /* WIN_COMMON_INCLUDED */
;|*** 
;|*** /***************************************************************************/
;|*** /****	    Window Manager Subsection part 1				****/
;|*** #if ((defined(INCL_WINWINDOWMGR) || !defined(INCL_NOCOMMON)) && !defined(INCL_WINWINDOWMGR_INCLUDED))
;|*** 
;|*** BOOL	APIENTRY WinRegisterClass(HAB hab, PSZ pszClassName, PFNWP pfnWndProc,
;|*** 				  ULONG flStyle, USHORT cbWindowData);
;|*** 
;|*** MRESULT APIENTRY WinDefWindowProc(HWND hwnd, USHORT msg, MPARAM mp1,
;|*** 				  MPARAM mp2);
;|*** BOOL	APIENTRY WinDestroyWindow(HWND hwnd);
;|*** BOOL	APIENTRY WinShowWindow(HWND hwnd, BOOL fShow);
;|*** BOOL	APIENTRY WinQueryWindowRect(HWND hwnd, PRECTL prclDest);
;|*** 
;|*** HPS   APIENTRY WinGetPS(HWND hwnd);
;|*** BOOL  APIENTRY WinReleasePS(HPS hps);
;|*** BOOL  APIENTRY WinEndPaint(HPS hps);
;|*** #ifndef INCL_SAADEFS
;|*** HPS   APIENTRY WinGetClipPS(HWND hwnd, HWND hwndClip, USHORT fs);
;|*** BOOL  APIENTRY WinIsWindowShowing(HWND hwnd);
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** HPS   APIENTRY WinBeginPaint(HWND hwnd, HPS hps, PRECTL prclPaint);
;|*** HDC   APIENTRY WinOpenWindowDC(HWND hwnd);
;|*** 
;|*** SHORT APIENTRY WinScrollWindow(HWND hwnd, SHORT dx, SHORT dy,
;|*** 			       PRECTL prclScroll, PRECTL prclClip,
;|*** 			       HRGN hrgnUpdate, PRECTL prclUpdate,
;|*** 			       USHORT fs);
;|*** 
;|*** /* WinGetClipPS() flags */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define PSF_LOCKWINDOWUPDATE	0x0001
;|*** #define PSF_CLIPUPWARDS 	0x0002
;|*** #define PSF_CLIPDOWNWARDS	0x0004
;|*** #define PSF_CLIPSIBLINGS	0x0008
;|*** #define PSF_CLIPCHILDREN	0x0010
;|*** #define PSF_PARENTCLIP		0x0020
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /* WinScrollWindow() flags */
;|*** 
;|*** #define SW_SCROLLCHILDREN	0x0001
;|*** #define SW_INVALIDATERGN	0x0002
;|*** 
;|*** BOOL  APIENTRY WinFillRect(HPS hps, PRECTL prcl, COLOR clr);
;|*** 
;|*** /* WinInitialize/WinTerminate Interface declarations */
;|*** 
;|*** typedef struct _QVERSDATA { /* qver */
;|*** 	USHORT environment;
;|*** 	USHORT version;
;|*** } QVERSDATA;
;|*** typedef QVERSDATA FAR *PQVERSDATA;
;|*** 
;|*** #define QV_OS2			0x0000
;|*** #define QV_CMS			0x0001
;|*** #define QV_TSO			0x0002
;|*** #define QV_TSOBATCH		0x0003
;|*** #define QV_OS400		0x0004
;|*** 
;|*** 
;|*** ULONG APIENTRY WinQueryVersion(HAB hab);
;|*** HAB   APIENTRY WinInitialize(USHORT fsOptions);
;|*** BOOL  APIENTRY WinTerminate(HAB hab);
;|*** 
;|*** HAB   APIENTRY WinQueryAnchorBlock(HWND hwnd);
;|*** 
;|*** #endif /* INCL_WINWINDOWMGR | !INCL_NOCOMMON */
;|*** /******************  End of Window Manager COMMON section ******************/
;|*** 
;|*** #ifndef WIN_COMMON2_INCLUDED
;|*** #define WIN_COMMON2_INCLUDED
;|*** 
;|*** HWND   APIENTRY WinCreateWindow(HWND hwndParent, PSZ pszClass, PSZ pszName,
;|*** 				ULONG flStyle, SHORT x, SHORT y, SHORT cx,
;|*** 				SHORT cy, HWND hwndOwner,
;|*** 				HWND hwndInsertBehind, USHORT id,
;|*** 				PVOID pCtlData, PVOID pPresParams);
;|*** BOOL   APIENTRY WinEnableWindow(HWND hwnd, BOOL fEnable);
;|*** BOOL   APIENTRY WinIsWindowEnabled(HWND hwnd);
;|*** BOOL   APIENTRY WinEnableWindowUpdate(HWND hwnd, BOOL fEnable);
;|*** BOOL   APIENTRY WinIsWindowVisible(HWND hwnd);
;|*** SHORT  APIENTRY WinQueryWindowText(HWND hwnd, SHORT cchBufferMax,
;|*** 				   PSZ pszBuf);
;|*** BOOL   APIENTRY WinSetWindowText(HWND hwnd, PSZ pszText);
;|*** SHORT  APIENTRY WinQueryWindowTextLength(HWND hwnd);
;|*** HWND   APIENTRY WinWindowFromID(HWND hwndParent, USHORT id);
;|*** 
;|*** BOOL   APIENTRY WinIsWindow(HAB hab, HWND hwnd);
;|*** HWND   APIENTRY WinQueryWindow(HWND hwnd, SHORT cmd, BOOL fLock);
;|*** SHORT  APIENTRY WinMultWindowFromIDs(HWND hwndParent, PHWND phwnd,
;|*** 				     USHORT idFirst, USHORT idLast);
;|*** 
;|*** /* WinQueryWindow() codes */
;|*** 
;|*** #define QW_NEXT 	0
;|*** #define QW_PREV 	1
;|*** #define QW_TOP		2
;|*** #define QW_BOTTOM	3
;|*** #define QW_OWNER	4
;|*** #define QW_PARENT	5
;|*** #define QW_NEXTTOP	6
;|*** #define QW_PREVTOP	7
;|*** #define QW_FRAMEOWNER	8
;|*** 
;|*** 
;|*** BOOL APIENTRY WinSetParent(HWND hwnd, HWND hwndNewParent, BOOL fRedraw);
;|*** 
;|*** BOOL APIENTRY WinIsChild(HWND hwnd, HWND hwndParent);
;|*** BOOL APIENTRY WinSetOwner(HWND hwnd, HWND hwndNewOwner);
;|*** #ifndef INCL_SAADEFS
;|*** BOOL APIENTRY WinQueryWindowProcess(HWND hwnd, PPID ppid, PTID ptid);
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** HWND APIENTRY WinQueryObjectWindow(HWND hwndDesktop);
;|*** HWND APIENTRY WinQueryDesktopWindow(HAB hab, HDC hdc);
;|*** 
;|*** /*** Window positioning functions */
;|*** 
;|*** /* WinSetMultWindowPos() structure */
;|*** typedef struct _SWP { /* swp */
;|*** 	USHORT	fs;
;|*** 	SHORT	cy;
;|*** 	SHORT	cx;
;|*** 	SHORT	y;
;|*** 	SHORT	x;
;|*** 	HWND	hwndInsertBehind;
;|*** 	HWND	hwnd;
;|*** } SWP;
;|*** typedef SWP FAR *PSWP;
;|*** 
;|*** BOOL APIENTRY WinSetWindowPos(HWND hwnd, HWND hwndInsertBehind, SHORT x,
;|*** 				SHORT y, SHORT cx, SHORT cy, USHORT fs);
;|*** BOOL APIENTRY WinQueryWindowPos(HWND hwnd, PSWP pswp);
;|*** BOOL APIENTRY WinSetMultWindowPos(HAB hab, PSWP pswp, USHORT cswp);
;|*** 
;|*** /* Values returned from WM_ADJUSTWINDOWPOS and passed to WM_WINDOWPOSCHANGED */
;|*** 
;|*** #define AWP_MINIMIZED		0x00010000L
;|*** #define AWP_MAXIMIZED		0x00020000L
;|*** #define AWP_RESTORED		0x00040000L
;|*** #define AWP_ACTIVATE		0x00080000L
;|*** #define AWP_DEACTIVATE		0x00100000L
;|*** 
;|*** /* WinSetWindowPos() flags */
;|*** 
;|*** #define SWP_SIZE		0x0001
;|*** #define SWP_MOVE		0x0002
;|*** #define SWP_ZORDER		0x0004
;|*** #define SWP_SHOW		0x0008
;|*** #define SWP_HIDE		0x0010
;|*** #define SWP_NOREDRAW		0x0020
;|*** #define SWP_NOADJUST		0x0040
;|*** #define SWP_ACTIVATE		0x0080
;|*** #define SWP_DEACTIVATE		0x0100
;|*** #define SWP_EXTSTATECHANGE	0x0200
;|*** #define SWP_MINIMIZE		0x0400
;|*** #define SWP_MAXIMIZE		0x0800
;|*** #define SWP_RESTORE		0x1000
;|*** #define SWP_FOCUSACTIVATE	0x2000
;|*** #define SWP_FOCUSDEACTIVATE	0x4000
;|*** 
;|*** /* Window painting */
;|*** 
;|*** BOOL APIENTRY WinUpdateWindow(HWND hwnd);
;|*** 
;|*** BOOL APIENTRY WinInvalidateRect(HWND hwnd, PRECTL prcl, BOOL fIncludeChildren);
;|*** BOOL APIENTRY WinInvalidateRegion(HWND hwnd, HRGN hrgn,
;|*** 				  BOOL fIncludeChildren);
;|*** 
;|*** /* Drawing helpers */
;|*** 
;|*** BOOL APIENTRY WinInvertRect(HPS hps, PRECTL prcl);
;|*** BOOL APIENTRY WinDrawBitmap(HPS hpsDst, HBITMAP hbm, PRECTL prclSrc,
;|*** 			    PPOINTL pptlDst, LONG clrFore, LONG clrBack,
;|*** 			    USHORT fs);
;|*** 
;|*** /* WinDrawBitmap() flags */
;|*** 
;|*** #define DBM_NORMAL		0x0000
;|*** #define DBM_INVERT		0x0001
;|*** #define DBM_HALFTONE		0x0002
;|*** #define DBM_STRETCH		0x0004
;|*** #define DBM_IMAGEATTRS		0x0008
;|*** 
;|*** 
;|*** SHORT APIENTRY WinDrawText(HPS hps, SHORT cchText, PCH lpchText, PRECTL prcl,
;|*** 			   LONG clrFore, LONG clrBack, USHORT fsCmd);
;|*** /*
;|***  * WinDrawText() codes:
;|***  * From DT_LEFT to DT_EXTERNALLEADING, the codes are designed to be OR'ed with
;|***  * SS_TEXT to create variations of the basic text static item.
;|***  */
;|*** #define DT_LEFT 		0x0000
;|*** #define DT_EXTERNALLEADING	0x0080
;|*** #define DT_CENTER		0x0100
;|*** #define DT_RIGHT		0x0200
;|*** #define DT_TOP			0x0000
;|*** #define DT_VCENTER		0x0400
;|*** #define DT_BOTTOM		0x0800
;|*** #define DT_HALFTONE		0x1000
;|*** #define DT_MNEMONIC		0x2000
;|*** #define DT_WORDBREAK		0x4000
;|*** #define DT_ERASERECT		0x8000
;|*** #define DT_QUERYEXTENT		0x0002
;|*** #define DT_TEXTATTRS		0x0040
;|*** 
;|*** 
;|*** BOOL APIENTRY WinDrawBorder(HPS hps, PRECTL prcl, SHORT cx, SHORT cy,
;|*** 			    LONG clrFore, LONG clrBack, USHORT fsCmd);
;|*** 
;|*** /* WinDrawBorder() flags */
;|*** 
;|*** #define DB_PATCOPY		0x0000
;|*** #define DB_PATINVERT		0x0001
;|*** #define DB_DESTINVERT		0x0002
;|*** #define DB_AREAMIXMODE		0x0003
;|*** 
;|*** #define DB_ROP			0x0007
;|*** #define DB_INTERIOR		0x0008
;|*** #define DB_AREAATTRS		0x0010
;|*** #define DB_STANDARD		0x0100
;|*** #define DB_DLGBORDER		0x0200
;|*** 
;|*** 
;|*** /** Resource loading functions */
;|*** 
;|*** SHORT APIENTRY WinLoadString(HAB hab, HMODULE hmod, USHORT id, SHORT cchMax,
;|*** 			     PSZ pszBuffer);
;|*** #ifndef INCL_SAADEFS
;|*** SHORT APIENTRY WinLoadMessage(HAB hab, HMODULE hmod, USHORT id, SHORT cchMax,
;|*** 			      PSZ pszBuffer);
;|*** 
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** #endif /* WIN_COMMON2_INCLUDED */
;|*** 
;|*** /***************************************************************************/
;|*** /****		      Window Manager Subsection part 2			****/
;|*** #if ((defined(INCL_WINWINDOWMGR) || !defined(INCL_NOCOMMON)) && !defined(INCL_WINWINDOWMGR_INCLUDED))
;|*** 
;|*** BOOL APIENTRY WinSetActiveWindow(HWND hwndDesktop, HWND hwnd);
;|*** 
;|*** #endif /* Window Manager COMMON subsection */
;|*** 
;|*** #if (defined(INCL_WINWINDOWMGR) && !defined(INCL_WINWINDOWMGR_INCLUDED))
;|*** 
;|*** /* WM_CREATE structure */
;|*** 
;|*** typedef struct _CREATESTRUCT { /* crst */
;|*** 	PVOID	pPresParams;
;|*** 	PVOID	pCtlData;
;|*** 	USHORT	id;
;|*** 	HWND	hwndInsertBehind;
;|*** 	HWND	hwndOwner;
;|*** 	SHORT	cy;
;|*** 	SHORT	cx;
;|*** 	SHORT	y;
;|*** 	SHORT	x;
;|*** 	ULONG	flStyle;
;|*** 	PSZ	pszText;
;|*** 	PSZ	pszClass;
;|*** 	HWND	hwndParent;
;|*** } CREATESTRUCT;
;|*** typedef CREATESTRUCT FAR *PCREATESTRUCT;
;|*** 
;|*** /* WinQueryClassInfo() structure */
;|*** 
;|*** typedef struct _CLASSINFO { /* clsi */
;|*** 	ULONG	flClassStyle;
;|*** 	PFNWP	pfnWindowProc;
;|*** 	USHORT	cbWindowData;
;|*** } CLASSINFO;
;|*** typedef CLASSINFO FAR *PCLASSINFO;
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** PFNWP  APIENTRY WinSubclassWindow(HWND hwnd, PFNWP pfnwp);
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** SHORT  APIENTRY WinQueryClassName(HWND hwnd, SHORT cchMax, PSZ psz);
;|*** BOOL   APIENTRY WinQueryClassInfo(HAB hab, PSZ pszClassName,
;|*** 				  PCLASSINFO pclsi);
;|*** 
;|*** HWND   APIENTRY WinQueryActiveWindow(HWND hwndDesktop, BOOL fLock);
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** BOOL   APIENTRY WinIsThreadActive(HAB hab);
;|*** #endif /* !INCL_SAADEFS */
;|*** HWND   APIENTRY WinQuerySysModalWindow(HWND hwndDesktop, BOOL fLock);
;|*** 
;|*** HWND   APIENTRY WinLockWindow(HWND hwnd, BOOL fLock);
;|*** #ifndef INCL_SAADEFS
;|*** BOOL   APIENTRY WinRegisterWindowDestroy(HWND hwnd, BOOL fRegister);
;|*** #endif /* !INCL_SAADEFS */
;|*** BOOL   APIENTRY WinSetSysModalWindow(HWND hwndDesktop, HWND hwnd);
;|*** 
;|*** SHORT  APIENTRY WinQueryWindowLockCount(HWND hwnd);
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** USHORT APIENTRY WinQueryWindowUShort(HWND hwnd, SHORT index);
;|*** BOOL   APIENTRY WinSetWindowUShort(HWND hwnd, SHORT index, USHORT us);
;|*** ULONG  APIENTRY WinQueryWindowULong(HWND hwnd, SHORT index);
;|*** BOOL   APIENTRY WinSetWindowULong(HWND hwnd, SHORT index, ULONG ul);
;|*** PVOID  APIENTRY WinQueryWindowPtr(HWND hwnd, SHORT index);
;|*** BOOL   APIENTRY WinSetWindowPtr(HWND hwnd, SHORT index, PVOID p);
;|*** BOOL   APIENTRY WinSetWindowBits(HWND hwnd, SHORT index, ULONG flData,
;|*** 				 ULONG flMask);
;|*** 
;|*** /* Standard WinQueryWindowUShort/ULong() indices */
;|*** 
;|*** #define QWS_USER		0
;|*** #define QWS_ID			(-1)
;|*** #define QWS_MIN 		(-1)
;|*** 
;|*** #define QWL_USER		0
;|*** #define QWL_STYLE		(-2)
;|*** #define QWP_PFNWP		(-3)
;|*** #define QWL_HMQ 		(-4)
;|*** #define QWL_MIN 		(-4)
;|*** 
;|*** /* WC_FRAME WinQueryWindowUShort/ULong() indices */
;|*** 
;|*** #define QWL_HHEAP		0x0004
;|*** #define QWL_HWNDFOCUSSAVE	0x0018
;|*** 
;|*** #define QWS_FLAGS		0x0008
;|*** #define QWS_RESULT		0x000a
;|*** #define QWS_XRESTORE		0x000c
;|*** #define QWS_YRESTORE		0x000e
;|*** #define QWS_CXRESTORE		0x0010
;|*** #define QWS_CYRESTORE		0x0012
;|*** #define QWS_XMINIMIZE		0x0014
;|*** #define QWS_YMINIMIZE		0x0016
;|*** 
;|*** 
;|*** /* Window enumeration */
;|*** 
;|*** typedef LHANDLE HENUM;  /* henum */
;|*** 
;|*** HENUM APIENTRY WinBeginEnumWindows(HWND hwnd);
;|*** HWND  APIENTRY WinGetNextWindow(HENUM henum);
;|*** BOOL  APIENTRY WinEndEnumWindows(HENUM henum);
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** HWND  APIENTRY WinWindowFromPoint(HWND hwnd, PPOINTL pptl, BOOL fChildren,
;|*** 				  BOOL fLock);
;|*** BOOL  APIENTRY WinMapWindowPoints(HWND hwndFrom, HWND hwndTo, PPOINTL pptl,
;|*** 				  SHORT cwpt);
;|*** 
;|*** /* WinExcludeUpdateRegion return values */
;|*** 
;|*** #define EXRGN_ERROR   0x0000
;|*** #define EXRGN_NULL    0x0001
;|*** #define EXRGN_RECT    0x0002
;|*** #define EXRGN_COMPLEX 0x0003
;|*** 
;|*** /* More window painting functions */
;|*** 
;|*** BOOL  APIENTRY WinValidateRect(HWND hwnd, PRECTL prcl, BOOL fIncludeChildren);
;|*** BOOL  APIENTRY WinValidateRegion(HWND hwnd, HRGN hrgn, BOOL fIncludeChildren);
;|*** #ifndef INCL_SAADEFS
;|*** HWND  APIENTRY WinWindowFromDC(HDC hdc);
;|*** HDC   APIENTRY WinQueryWindowDC(HWND hwnd);
;|*** HPS   APIENTRY WinGetScreenPS(HWND hwndDesktop);
;|*** BOOL  APIENTRY WinLockWindowUpdate(HWND hwndDesktop, HWND hwndLockUpdate);
;|*** BOOL  APIENTRY WinLockVisRegions(HWND hwndDesktop, BOOL fLock);
;|*** #endif /* !INCL_SAADEFS */
;|*** BOOL  APIENTRY WinQueryUpdateRect(HWND hwnd, PRECTL prcl);
;|*** SHORT APIENTRY WinQueryUpdateRegion(HWND hwnd, HRGN hrgn);
;|*** SHORT APIENTRY WinExcludeUpdateRegion(HPS hps, HWND hwnd);
;|*** 
;|*** #endif /* INCL_WINWINDOWMGR */
;|*** 
;|*** #if ((defined(INCL_WINMESSAGEMGR) || !defined(INCL_NOCOMMON)) && !defined(INCL_WINMESSAGEMGR_INCLUDED))
;|*** 
;|*** /* QMSG structure */
;|*** 
;|*** typedef struct _QMSG { /* qmsg */
;|*** 	HWND	hwnd;
;|*** 	USHORT	msg;
;|*** 	MPARAM	mp1;
;|*** 	MPARAM	mp2;
;|*** 	ULONG	time;
;|*** 	POINTL	ptl;
;|*** } QMSG;
;|*** typedef QMSG FAR *PQMSG;
;|*** 
;|*** typedef LHANDLE HMQ;    /* hmq */
;|*** 
;|*** /*
;|*** ** This is the standard function definition for window procedures.
;|*** ** Typically they are names like "XxxxxxxxWndProc", where the prefix
;|*** ** "Xxxxxxxxx" is replaced by some name descriptive of the window procedure
;|*** ** being declared.  Window procedures must be EXPORTED in the definitions
;|*** ** file used by the linker.
;|*** **
;|*** ** MRESULT EXPENTRY MyclassWndProc(HWND hwnd,	** window handle	**
;|*** **				   USHORT msg,	** message number	**
;|*** **				   MPARAM mp1,	** 1st (packed) parms	**
;|*** **				   MPARAM mp2); ** 2nd (packed) parms	**
;|*** */
;|*** 
;|*** /* Standard Window Messages */
;|*** 
;|*** #define WM_NULL 		0x0000
;|*** #define WM_CREATE		0x0001
;|*** #define WM_DESTROY		0x0002
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define WM_OTHERWINDOWDESTROYED 0x0003
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define WM_ENABLE		0x0004
;|*** #define WM_SHOW 		0x0005
;|*** #define WM_MOVE 		0x0006
;|*** #define WM_SIZE 		0x0007
;|*** #define WM_ADJUSTWINDOWPOS	0x0008
;|*** 
;|*** #define WM_CALCVALIDRECTS	0x0009
;|*** 
;|*** #define WM_SETWINDOWPARAMS	0x000a
;|*** #define WM_QUERYWINDOWPARAMS	0x000b
;|*** #define WM_HITTEST		0x000c
;|*** #define WM_ACTIVATE		0x000d
;|*** #define WM_SETFOCUS		0x000f
;|*** #define WM_SETSELECTION 	0x0010
;|*** 
;|*** /* language support Winproc */
;|*** #define WM_PPAINT		0x0011
;|*** #define WM_PSETFOCUS		0x0012
;|*** #define WM_PSYSCOLORCHANGE	0x0013
;|*** #define WM_PSIZE		0x0014
;|*** #define WM_PACTIVATE		0x0015
;|*** #define WM_PCONTROL		0x0016
;|*** 
;|*** 
;|*** #define WM_COMMAND		0x0020
;|*** #define WM_SYSCOMMAND		0x0021
;|*** #define WM_HELP 		0x0022
;|*** #define WM_PAINT		0x0023
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define WM_TIMER		0x0024
;|*** #define WM_SEM1 		0x0025
;|*** #define WM_SEM2 		0x0026
;|*** #define WM_SEM3 		0x0027
;|*** #define WM_SEM4 		0x0028
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define WM_CLOSE		0x0029
;|*** #define WM_QUIT 		0x002a
;|*** #define WM_SYSCOLORCHANGE	0x002b
;|*** #define WM_SYSVALUECHANGED	0x002d
;|*** #define WM_APPTERMINATENOTIFY	0x002e
;|*** #define WM_PRESPARAMCHANGED	0x002f
;|*** 
;|*** /* Control notification messages */
;|*** 
;|*** #define WM_CONTROL		0x0030
;|*** #define WM_VSCROLL		0x0031
;|*** #define WM_HSCROLL		0x0032
;|*** #define WM_INITMENU		0x0033
;|*** #define WM_MENUSELECT		0x0034
;|*** #define WM_MENUEND		0x0035
;|*** #define WM_DRAWITEM		0x0036
;|*** #define WM_MEASUREITEM		0x0037
;|*** #define WM_CONTROLPOINTER	0x0038
;|*** #define WM_CONTROLHEAP		0x0039
;|*** #define WM_QUERYDLGCODE 	0x003a
;|*** #define WM_INITDLG		0x003b
;|*** #define WM_SUBSTITUTESTRING	0x003c
;|*** #define WM_MATCHMNEMONIC	0x003d
;|*** #define WM_SAVEAPPLICATION	0x003e
;|*** 
;|*** /* Reserve a range of messages for help manager.  This range includes  */
;|*** /* public messages, defined below, and private ones, which need to be  */
;|*** /* reserved here to prevent clashing with application messages         */
;|*** 
;|*** #define WM_HELPBASE		0x0F00 /* Start of msgs for help manager */
;|*** #define WM_HELPTOP		0x0FFF /* End of msgs for help manager	 */
;|*** 
;|*** #define WM_USER 		0x1000
;|*** 
;|*** /* WM_COMMAND msg source codes */
;|*** 
;|*** #define CMDSRC_PUSHBUTTON	1
;|*** #define CMDSRC_MENU		2
;|*** #define CMDSRC_ACCELERATOR	3
;|*** #define CMDSRC_OTHER		0
;|*** 
;|*** /*
;|***  * The following structure and macro are used to access the
;|***  * WM_COMMAND, WM_HELP, and WM_SYSCOMMAND message parameters:
;|***  */
;|*** typedef struct _COMMANDMSG { /* commandmsg */
;|*** 	USHORT	source; 	/* mp2 */
;|*** 	BOOL	fMouse;
;|*** 	USHORT	cmd;		/* mp1 */
;|*** 	USHORT	unused;
;|*** } CMDMSG;
;|*** 
;|*** #define COMMANDMSG(pmsg) \
;|*** 	((struct _COMMANDMSG FAR *)((PBYTE)pmsg - sizeof(MPARAM) * 2))
;|*** 
;|*** /*
;|***  * The following structure is used by the WinQueryQueueInfo() routine
;|***  */
;|*** typedef struct _MQINFO { /* mqi */
;|*** 	USHORT	cb;
;|*** 	PID	pid;
;|*** 	TID	tid;
;|*** 	USHORT	cmsgs;
;|*** 	PVOID	pReserved;
;|*** } MQINFO;
;|*** typedef MQINFO FAR *PMQINFO;
;|*** 
;|*** /* WinCreateMsgQueue default size */
;|*** 
;|*** #define DEFAULT_QUEUE_SIZE  0x0000
;|*** 
;|*** MRESULT APIENTRY WinSendMsg(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2);
;|*** HMQ	APIENTRY WinCreateMsgQueue(HAB hab, SHORT cmsg);
;|*** BOOL	APIENTRY WinDestroyMsgQueue(HMQ hmq);
;|*** BOOL	APIENTRY WinQueryQueueInfo(HMQ hmq, PMQINFO pmqi, USHORT cbCopy);
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** BOOL	APIENTRY WinCancelShutdown(HMQ hmq, BOOL fCancelAlways);
;|*** #endif /* INCL_SAADEFS */
;|*** 
;|*** BOOL	APIENTRY WinGetMsg(HAB hab, PQMSG pqmsg, HWND hwndFilter,
;|*** 			   USHORT msgFilterFirst, USHORT msgFilterLast);
;|*** BOOL	APIENTRY WinPeekMsg(HAB hab, PQMSG pqmsg, HWND hwndFilter,
;|*** 			    USHORT msgFilterFirst, USHORT msgFilterLast,
;|*** 			    USHORT fs);
;|*** 
;|*** MRESULT APIENTRY WinDispatchMsg(HAB hab, PQMSG pqmsg);
;|*** 
;|*** BOOL	APIENTRY WinPostMsg(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2);
;|*** BOOL	APIENTRY WinRegisterUserMsg(HAB hab, USHORT msgid, SHORT datatype1,
;|*** 				    SHORT dir1, SHORT datatype2, SHORT dir2,
;|*** 				    SHORT datatyper);
;|*** BOOL	APIENTRY WinRegisterUserDatatype(HAB hab, SHORT datatype,
;|*** 					 SHORT count, PSHORT types);
;|*** BOOL	APIENTRY WinSetMsgMode(HAB hab, PSZ classname,
;|*** 			       SHORT control);
;|*** BOOL	APIENTRY WinSetSynchroMode(HAB hab, SHORT mode);
;|*** 
;|*** /* WinPeekMsg() constants */
;|*** 
;|*** #define PM_REMOVE		0x0001
;|*** #define PM_NOREMOVE		0x0000
;|*** 
;|*** /* WinRegisterUserDatatype datatypes defined in separate file */
;|*** #if (defined(INCL_WINTYPES) && !defined(PMTYPES_INCLUDED))
;|*** #include <pmtypes.h>
;|*** #endif /*INCL_WINTYPES*/
;|*** 
;|*** /* WinRegisterUserMsg direction codes */
;|*** 
;|*** #define RUM_IN			1
;|*** #define RUM_OUT 		2
;|*** #define RUM_INOUT		3
;|*** 
;|*** /* WinSetMsgMode constants */
;|*** 
;|*** #define SMD_DELAYED		0x0001
;|*** #define SMD_IMMEDIATE		0x0002
;|*** 
;|*** /* WinSetSynchroMode constants */
;|*** 
;|*** #define SSM_SYNCHRONOUS 	0x0001
;|*** #define SSM_ASYNCHRONOUS	0x0002
;|*** #define SSM_MIXED		0x0003
;|*** 
;|*** #endif /* WINMESSAGEMGR || !INCL_NOCOMMON       */
;|*** 
;|*** #if (defined(INCL_WINMESSAGEMGR) && !defined(INCL_WINMESSAGEMGR_INCLUDED))
;|*** #define INCL_WINMESSAGEMGR_INCLUDED
;|*** 
;|*** /* WM_CALCVALIDRECTS return flags */
;|*** 
;|*** #define CVR_ALIGNLEFT		0x0001
;|*** #define CVR_ALIGNBOTTOM 	0x0002
;|*** #define CVR_ALIGNRIGHT		0x0004
;|*** #define CVR_ALIGNTOP		0x0008
;|*** #define CVR_REDRAW		0x0010
;|*** 
;|*** 
;|*** /* WM_HITTEST return codes */
;|*** 
;|*** #define HT_NORMAL		0
;|*** #define HT_TRANSPARENT		(-1)
;|*** #define HT_DISCARD		(-2)
;|*** #define HT_ERROR		(-3)
;|*** 
;|*** 
;|*** /* WM_SET/QUERYWINDOWPARAMS structures and flags */
;|*** 
;|*** typedef struct _WNDPARAMS { /* wprm */
;|*** 	USHORT	fsStatus;
;|*** 	USHORT	cchText;
;|*** 	PSZ	pszText;
;|*** 	USHORT	cbPresParams;
;|*** 	PVOID	pPresParams;
;|*** 	USHORT	cbCtlData;
;|*** 	PVOID	pCtlData;
;|*** } WNDPARAMS;
;|*** typedef WNDPARAMS FAR *PWNDPARAMS;
;|*** 
;|*** /* Flags used by WM_SET/QUERYWINDOWPARAMS */
;|*** 
;|*** #define WPM_TEXT		0x0001
;|*** #define WPM_CTLDATA		0x0002
;|*** #define WPM_PRESPARAMS		0x0004
;|*** #define WPM_CCHTEXT		0x0008
;|*** #define WPM_CBCTLDATA		0x0010
;|*** #define WPM_CBPRESPARAMS	0x0020
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** BOOL    APIENTRY WinInSendMsg(HAB hab);
;|*** 
;|*** #endif /* INCL_SAADEFS */
;|*** 
;|*** BOOL    APIENTRY WinBroadcastMsg(HWND hwnd, USHORT msg, MPARAM mp1, MPARAM mp2,
;|*** 				 USHORT fs);
;|*** 
;|*** /* WinBroadcastMsg codes */
;|*** 
;|*** #define BMSG_POST		0x0000
;|*** #define BMSG_SEND		0x0001
;|*** #define BMSG_POSTQUEUE		0x0002
;|*** #define BMSG_DESCENDANTS	0x0004
;|*** #define BMSG_FRAMEONLY		0x0008
;|*** 
;|*** 
;|*** BOOL  APIENTRY WinWaitMsg(HAB hab, USHORT msgFirst, USHORT msgLast);
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** ULONG APIENTRY WinQueryQueueStatus(HWND hwndDesktop);
;|*** 
;|*** /* WinQueryQueueStatus() constants */
;|*** 
;|*** #define QS_KEY			0x0001
;|*** #define QS_MOUSEBUTTON		0x0002
;|*** #define QS_MOUSEMOVE		0x0004
;|*** #define QS_MOUSE		0x0006	 /* QS_MOUSEMOVE|QS_MOUSEBUTTON */
;|*** #define QS_TIMER		0x0008
;|*** #define QS_PAINT		0x0010
;|*** #define QS_POSTMSG		0x0020
;|*** #define QS_SEM1 		0x0040
;|*** #define QS_SEM2 		0x0080
;|*** #define QS_SEM3 		0x0100
;|*** #define QS_SEM4 		0x0200
;|*** #define QS_SENDMSG		0x0400
;|*** 
;|*** 
;|*** BOOL  APIENTRY WinQueryMsgPos(HAB hab, PPOINTL pptl);
;|*** ULONG APIENTRY WinQueryMsgTime(HAB hab);
;|*** 
;|*** USHORT APIENTRY WinMsgSemWait(HSEM hsem, LONG lTimeout);
;|*** USHORT APIENTRY WinMsgMuxSemWait(PUSHORT pisemCleared, PVOID pmxsl,
;|***                                  LONG dtTimeout);
;|*** #endif /* !INCL_SAADEFS */
;|*** BOOL  APIENTRY WinPostQueueMsg(HMQ hmq, USHORT msg, MPARAM mp1, MPARAM mp2);
;|*** 
;|*** #endif /* INCL_WINMESSAGEMGR */
;|*** 
;|*** /*** Keyboard and mouse */
;|*** 
;|*** #if (defined(INCL_WININPUT) || !defined(INCL_NOCOMMON))
;|*** 
;|*** /*** Keyboard and mouse input COMMON subsection */
;|*** BOOL  APIENTRY WinSetFocus(HWND hwndDesktop, HWND hwndSetFocus);
;|*** BOOL  APIENTRY WinFocusChange(HWND hwndDesktop, HWND hwndSetFocus,
;|***                               USHORT fsFocusChange);
;|*** 
;|*** #define FC_NOSETFOCUS		 0x0001
;|*** #define FC_NOBRINGTOTOP 	 FC_NOSETFOCUS
;|*** #define FC_NOLOSEFOCUS		 0x0002
;|*** #define FC_NOBRINGTOPFIRSTWINDOW FC_NOLOSEFOCUS
;|*** #define FC_NOSETACTIVEFOCUS	 0x0003
;|*** #define FC_NOSETACTIVE		 0x0004
;|*** #define FC_NOLOSEACTIVE 	 0x0008
;|*** #define FC_NOSETSELECTION	 0x0010
;|*** #define FC_NOLOSESELECTION	 0x0020
;|*** 
;|*** #define QFC_NEXTINCHAIN 	 0x0001
;|*** #define QFC_ACTIVE		 0x0002
;|*** #define QFC_FRAME		 0x0003
;|*** #define QFC_SELECTACTIVE	 0x0004
;|*** 
;|*** #endif  /* Keyboard and mouse input COMMON subsection */
;|*** 
;|*** #if (defined(INCL_WININPUT) && !defined(INCL_WININPUT_INCLUDED))
;|*** #define INCL_WININPUT_INCLUDED
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** BOOL  APIENTRY WinSetCapture(HWND hwndDesktop, HWND hwnd);
;|*** #endif /* !INCL_SAADEFS */
;|*** HWND  APIENTRY WinQueryCapture(HWND hwndDesktop, BOOL fLock);
;|*** 
;|*** /* Mouse input messages */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define WM_MOUSEFIRST		0x0070
;|*** #define WM_MOUSELAST		0x0079
;|*** #define WM_BUTTONCLICKFIRST	0x0071
;|*** #define WM_BUTTONCLICKLAST	0x0079
;|*** #endif /* !INCL_SAADEFS */
;|*** #define WM_MOUSEMOVE		0x0070
;|*** 
;|*** #define WM_BUTTON1DOWN		0x0071
;|*** 
;|*** #define WM_BUTTON1UP		0x0072
;|*** #define WM_BUTTON1DBLCLK	0x0073
;|*** #define WM_BUTTON2DOWN		0x0074
;|*** #define WM_BUTTON2UP		0x0075
;|*** #define WM_BUTTON2DBLCLK	0x0076
;|*** #ifndef INCL_SAADEFS
;|*** #define WM_BUTTON3DOWN		0x0077
;|*** #define WM_BUTTON3UP		0x0078
;|*** #define WM_BUTTON3DBLCLK	0x0079
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** HWND  APIENTRY WinQueryFocus(HWND hwndDesktop, BOOL fLock);
;|*** 
;|*** 
;|*** /* Key/Character input messages */
;|*** 
;|*** #define WM_CHAR 		0x007a
;|*** #define WM_VIOCHAR		0x007b
;|*** 
;|*** /* WM_CHAR fs field bits */
;|*** 
;|*** #define KC_CHAR 		0x0001
;|*** #define KC_VIRTUALKEY		0x0002
;|*** #define KC_SCANCODE		0x0004
;|*** 
;|*** #define KC_SHIFT		0x0008
;|*** #define KC_CTRL 		0x0010
;|*** #define KC_ALT			0x0020
;|*** #define KC_KEYUP		0x0040
;|*** #define KC_PREVDOWN		0x0080
;|*** #define KC_LONEKEY		0x0100
;|*** #define KC_DEADKEY		0x0200
;|*** #define KC_COMPOSITE		0x0400
;|*** #define KC_INVALIDCOMP		0x0800
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define KC_TOGGLE		0x1000
;|*** #define KC_INVALIDCHAR		0x2000
;|*** #define KC_DBCSRSRVD1		0x4000
;|*** #define KC_DBCSRSRVD2		0x8000
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /*
;|***  * The following structure and macro are used to access the
;|***  * WM_MOUSEMOVE, and WM_BUTTON message parameters
;|***  */
;|*** typedef struct _MOUSEMSG { /* mousemsg */
;|*** 	USHORT	codeHitTest;	/* mp2	*/
;|*** 	USHORT	unused;
;|*** 	SHORT	x;		/* mp1	*/
;|*** 	SHORT	y;
;|*** } MSEMSG;
;|*** 
;|*** #define MOUSEMSG(pmsg) \
;|*** 	((struct _MOUSEMSG FAR *)((PBYTE)pmsg - sizeof(MPARAM) * 2))
;|*** 
;|*** /*
;|***  * The following structure and macro are used to access the
;|***  * WM_CHAR message parameters.
;|***  */
;|*** typedef struct _CHARMSG { /* charmsg */
;|*** 	USHORT	chr;		/* mp2	*/
;|*** 	USHORT	vkey;
;|*** 	USHORT	fs;		/* mp1	*/
;|*** 	UCHAR	cRepeat;
;|*** 	UCHAR	scancode;
;|*** } CHRMSG;
;|*** 
;|*** #define CHARMSG(pmsg) \
;|*** 	((struct _CHARMSG FAR *)((PBYTE)pmsg - sizeof(MPARAM) * 2))
;|*** 
;|*** /*** Virtual key values */
;|*** 
;|*** #define VK_BUTTON1		0x01
;|*** #define VK_BUTTON2		0x02
;|*** #define VK_BUTTON3		0x03
;|*** #define VK_BREAK		0x04
;|*** #define VK_BACKSPACE		0x05
;|*** #define VK_TAB			0x06
;|*** #define VK_BACKTAB		0x07
;|*** #define VK_NEWLINE		0x08
;|*** #define VK_SHIFT		0x09
;|*** #define VK_CTRL 		0x0A
;|*** #define VK_ALT			0x0B
;|*** #define VK_ALTGRAF		0x0C
;|*** #define VK_PAUSE		0x0D
;|*** #define VK_CAPSLOCK		0x0E
;|*** #define VK_ESC			0x0F
;|*** #define VK_SPACE		0x10
;|*** #define VK_PAGEUP		0x11
;|*** #define VK_PAGEDOWN		0x12
;|*** #define VK_END			0x13
;|*** #define VK_HOME 		0x14
;|*** #define VK_LEFT 		0x15
;|*** #define VK_UP			0x16
;|*** #define VK_RIGHT		0x17
;|*** #define VK_DOWN 		0x18
;|*** #define VK_PRINTSCRN		0x19
;|*** #define VK_INSERT		0x1A
;|*** #define VK_DELETE		0x1B
;|*** #define VK_SCRLLOCK		0x1C
;|*** #define VK_NUMLOCK		0x1D
;|*** #define VK_ENTER		0x1E
;|*** #define VK_SYSRQ		0x1F
;|*** #define VK_F1			0x20
;|*** #define VK_F2			0x21
;|*** #define VK_F3			0x22
;|*** #define VK_F4			0x23
;|*** #define VK_F5			0x24
;|*** #define VK_F6			0x25
;|*** #define VK_F7			0x26
;|*** #define VK_F8			0x27
;|*** #define VK_F9			0x28
;|*** #define VK_F10			0x29
;|*** #define VK_F11			0x2A
;|*** #define VK_F12			0x2B
;|*** #define VK_F13			0x2C
;|*** #define VK_F14			0x2D
;|*** #define VK_F15			0x2E
;|*** #define VK_F16			0x2F
;|*** #define VK_F17			0x30
;|*** #define VK_F18			0x31
;|*** #define VK_F19			0x32
;|*** #define VK_F20			0x33
;|*** #define VK_F21			0x34
;|*** #define VK_F22			0x35
;|*** #define VK_F23			0x36
;|*** #define VK_F24			0x37
;|*** 
;|*** 
;|*** #define VK_MENU 		VK_F10
;|*** #ifdef INCL_NLS
;|*** #define VK_DBCSFIRST		0x0080
;|*** #define VK_DBCSLAST		0x00ff
;|*** #endif /* INCL_NLS */
;|*** 
;|*** #define VK_USERFIRST		0x0100
;|*** #define VK_USERLAST		0x01ff
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** 
;|*** SHORT APIENTRY WinGetKeyState(HWND hwndDesktop, SHORT vkey);
;|*** SHORT APIENTRY WinGetPhysKeyState(HWND hwndDesktop, SHORT sc);
;|*** BOOL  APIENTRY WinEnablePhysInput(HWND hwndDesktop, BOOL fEnable);
;|*** BOOL  APIENTRY WinIsPhysInputEnabled(HWND hwndDesktop);
;|*** BOOL  APIENTRY WinSetKeyboardStateTable(HWND hwndDesktop,
;|*** 					PBYTE pKeyStateTable, BOOL fSet);
;|*** 
;|*** 
;|*** /* Journal Notification messages  */
;|*** #define WM_JOURNALNOTIFY	0x007c
;|*** 
;|*** /*** Define the valid commands (lParm1) for journal notify message */
;|*** #define JRN_QUEUESTATUS 	0x00000001L
;|*** #define JRN_PHYSKEYSTATE	0x00000002L
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** #endif /* INCL_WININPUT */
;|*** 
;|*** 
;|*** /**** Dialog Manager */
;|*** 
;|*** #if (defined(INCL_WINDIALOGS) || !defined(INCL_NOCOMMON))
;|*** /**** Dialog Manager COMMON subsection */
;|*** 
;|*** /*
;|*** ** This is the standard function definition for dialog procedures.
;|*** ** Typically they are names like "XxxxxxxxDlgProc", where the prefix
;|*** ** "Xxxxxxxxx" is replaced by some name descriptive of the dialog procedure
;|*** ** being declared.  Dialog procedures must be EXPORTED in the definitions
;|*** ** file used by the linker.  The dialog procedure declaration is identical
;|*** ** to that for window procedures.
;|*** **
;|*** ** MRESULT EXPENTRY MydialogDlgProc(HWND hwnd,	 ** window handle	 **
;|*** **				    USHORT msg,  ** message number	 **
;|*** **				    MPARAM mp1,  ** 1st (packed) parms	 **
;|*** **				    MPARAM mp2); ** 2nd (packed) parms	 **
;|*** */
;|*** 
;|*** BOOL	APIENTRY WinGetDlgMsg(HWND hwndDlg, PQMSG pqmsg);
;|*** 
;|*** 
;|*** HWND	APIENTRY WinLoadDlg(HWND hwndParent, HWND hwndOwner, PFNWP pfnDlgProc,
;|*** 			    HMODULE hmod, USHORT idDlg, PVOID pCreateParams);
;|*** USHORT	APIENTRY WinDlgBox(HWND hwndParent, HWND hwndOwner, PFNWP pfnDlgProc,
;|*** 			   HMODULE hmod, USHORT idDlg, PVOID pCreateParams);
;|*** 
;|*** BOOL	APIENTRY WinDismissDlg(HWND hwndDlg, USHORT usResult);
;|*** 
;|*** BOOL	APIENTRY WinQueryDlgItemShort(HWND hwndDlg, USHORT idItem,
;|*** 				      PSHORT psResult, BOOL fSigned);
;|*** BOOL	APIENTRY WinSetDlgItemShort(HWND hwndDlg, USHORT idItem,
;|*** 				    USHORT usValue, BOOL fSigned);
;|*** BOOL	APIENTRY WinSetDlgItemText(HWND hwndDlg, USHORT idItem, PSZ pszText);
;|*** USHORT	APIENTRY WinQueryDlgItemText(HWND hwndDlg, USHORT idItem,
;|*** 				     SHORT cchBufferMax, PSZ pszBuf);
;|*** SHORT	APIENTRY WinQueryDlgItemTextLength(HWND hwndDlg, USHORT idItem);
;|*** 
;|*** MRESULT APIENTRY WinDefDlgProc(HWND hwndDlg, USHORT msg, MPARAM mp1,
;|***                                MPARAM mp2);
;|*** 
;|*** /* Special item IDs */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define DID_OK      1
;|*** #define DID_CANCEL  2
;|*** #define DID_ERROR   0xffff
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** BOOL APIENTRY WinAlarm(HWND hwndDesktop, USHORT fsType);
;|*** 
;|*** /* WinAlarm Codes */
;|*** 
;|*** #define WA_WARNING		0
;|*** #define WA_NOTE 		1
;|*** #define WA_ERROR		2
;|*** #define WA_CWINALARMS		3
;|*** 
;|*** USHORT APIENTRY WinMessageBox(HWND hwndParent, HWND hwndOwner, PSZ pszText,
;|***                               PSZ pszCaption, USHORT idWindow, USHORT flStyle);
;|*** 
;|*** /* Message box types */
;|*** 
;|*** #define MB_OK			0x0000
;|*** #define MB_OKCANCEL		0x0001
;|*** #define MB_RETRYCANCEL		0x0002
;|*** #define MB_ABORTRETRYIGNORE	0x0003
;|*** #define MB_YESNO		0x0004
;|*** #define MB_YESNOCANCEL		0x0005
;|*** #define MB_CANCEL		0x0006
;|*** #define MB_ENTER		0x0007
;|*** #define MB_ENTERCANCEL		0x0008
;|*** 
;|*** #define MB_NOICON		0x0000
;|*** #define MB_CUANOTIFICATION	0x0000
;|*** #define MB_ICONQUESTION 	0x0010
;|*** #define MB_ICONEXCLAMATION	0x0020
;|*** #define MB_CUAWARNING		0x0020
;|*** #define MB_ICONASTERISK 	0x0030
;|*** #define MB_ICONHAND		0x0040
;|*** #define MB_CUACRITICAL		0x0040
;|*** #define MB_QUERY		MB_ICONQUESTION
;|*** #define MB_WARNING		MB_CUAWARNING
;|*** #define MB_INFORMATION		MB_ICONASTERISK
;|*** #define MB_CRITICAL		MB_CUACRITICAL
;|*** #define MB_ERROR		MB_CRITICAL
;|*** 
;|*** #define MB_DEFBUTTON1		0x0000
;|*** #define MB_DEFBUTTON2		0x0100
;|*** #define MB_DEFBUTTON3		0x0200
;|*** 
;|*** #define MB_APPLMODAL		0x0000
;|*** #define MB_SYSTEMMODAL		0x1000
;|*** #define MB_HELP 		0x2000
;|*** #define MB_MOVEABLE		0x4000
;|*** 
;|*** 
;|*** /* Message box return codes */
;|*** 
;|*** #define MBID_OK 		1
;|*** #define MBID_CANCEL		2
;|*** #define MBID_ABORT		3
;|*** #define MBID_RETRY		4
;|*** #define MBID_IGNORE		5
;|*** #define MBID_YES		6
;|*** #define MBID_NO 		7
;|*** #define MBID_HELP		8
;|*** #define MBID_ENTER		9
;|*** #define MBID_ERROR		0xffff
;|*** 
;|*** #endif /* Dialog Manager COMMON subsection */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINDIALOGS) && !defined(INCL_WINDIALOGS_INCLUDED))
;|*** #define INCL_WINDIALOGS_INCLUDED
;|*** 
;|*** /* Dialog codes: returned by WM_QUERYDLGCODE msg     */
;|*** 
;|*** #define DLGC_ENTRYFIELD  0x0001 /* Entry field item understands EM_SETSEL) */
;|*** #define DLGC_BUTTON	 0x0002 /* Button item				   */
;|*** #define DLGC_RADIOBUTTON 0x0004 /* Radio button 			   */
;|*** #define DLGC_STATIC	 0x0008 /* Static item				   */
;|*** #define DLGC_DEFAULT	 0x0010 /* Default push button			   */
;|*** #define DLGC_PUSHBUTTON  0x0020 /* Normal (Non-default) push button	   */
;|*** #define DLGC_CHECKBOX	 0x0040 /* Check box button control		   */
;|*** #define DLGC_SCROLLBAR	 0x0080 /* Scroll bar				   */
;|*** #define DLGC_MENU	 0x0100 /* Menu 				   */
;|*** #define DLGC_TABONCLICK  0x0200
;|*** #define DLGC_MLE	 0x0400 /* Multiple Line Entry			   */
;|*** 
;|*** 
;|*** USHORT	APIENTRY WinProcessDlg(HWND hwndDlg);
;|*** USHORT	APIENTRY WinStartDlg(HWND hwndDlg);
;|*** MRESULT APIENTRY WinSendDlgItemMsg(HWND hwndDlg, USHORT idItem, USHORT msg,
;|*** 				   MPARAM mp1, MPARAM mp2);
;|*** BOOL	APIENTRY WinMapDlgPoints(HWND hwndDlg, PPOINTL pptl, USHORT cwpt,
;|*** 				 BOOL fCalcWindowCoords);
;|*** HWND	APIENTRY WinEnumDlgItem(HWND hwndDlg, HWND hwnd, USHORT code,
;|*** 				BOOL fLock);
;|*** SHORT	APIENTRY WinSubstituteStrings(HWND hwnd, PSZ pszSrc, SHORT cchDstMax,
;|*** 				      PSZ pszDst);
;|*** 
;|*** /* WinEnumDlgItem() constants
;|***  *
;|***  * In OS/2 1.2, WinEnumDlgItem() can enumerate a window such that the
;|***  * selection cursor may be moved  according to CUA (Common User Access)
;|***  * rules.
;|***  */
;|*** 
;|*** #define EDI_FIRSTTABITEM	0
;|*** #define EDI_LASTTABITEM 	1
;|*** #define EDI_NEXTTABITEM 	2
;|*** #define EDI_PREVTABITEM 	3
;|*** #define EDI_FIRSTGROUPITEM	4
;|*** #define EDI_LASTGROUPITEM	5
;|*** #define EDI_NEXTGROUPITEM	6
;|*** #define EDI_PREVGROUPITEM	7
;|*** 
;|*** /*** Dialog template definitions */
;|*** 
;|*** /* Variable-sized dialog template items: */
;|*** 
;|*** typedef struct _DLGTITEM { /* dlgti */
;|*** 	USHORT	fsItemStatus;
;|*** 	USHORT	cChildren;
;|*** 	USHORT	cchClassName;
;|*** 	USHORT	offClassName;
;|*** 	USHORT	cchText;
;|*** 	USHORT	offText;
;|*** 	ULONG	flStyle;
;|*** 	SHORT	x;
;|*** 	SHORT	y;
;|*** 	SHORT	cx;
;|*** 	SHORT	cy;
;|*** 	USHORT	id;
;|*** 	USHORT	offPresParams;
;|*** 	USHORT	offCtlData;
;|*** } DLGTITEM;
;|*** typedef DLGTITEM FAR *PDLGTITEM;
;|*** 
;|*** /* Dialog Template structure */
;|*** 
;|*** typedef struct _DLGTEMPLATE { /* dlgt */
;|*** 	USHORT	 cbTemplate;
;|*** 	USHORT	 type;
;|*** 	USHORT	 codepage;
;|*** 	USHORT	 offadlgti;
;|*** 	USHORT	 fsTemplateStatus;
;|*** 	USHORT	 iItemFocus;
;|*** 	USHORT	 coffPresParams;
;|*** 	DLGTITEM adlgti[1];
;|*** } DLGTEMPLATE;
;|*** typedef DLGTEMPLATE FAR *PDLGTEMPLATE;
;|*** 
;|*** HWND APIENTRY WinCreateDlg(HWND hwndParent, HWND hwndOwner, PFNWP pfnDlgProc,
;|*** 			   PDLGTEMPLATE pdlgt, PVOID pCreateParams);
;|*** 
;|*** 
;|*** #endif /* INCL_WINDIALOGS */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINSTATICS) && !defined(INCL_WINSTATICS_INCLUDED))
;|*** #define INCL_WINSTATICS_INCLUDED
;|*** 
;|*** /*** Static Control Manager */
;|*** 
;|*** /* Static control styles:
;|***  *
;|***  * NOTE: the top 9 bits of the LOWORD of the window flStyle are used for
;|***  * DT_* flags.  The lower 7 bits are for SS_* styles.  This gives us up
;|***  * to 128 distinct static control types (we currently use 11 of them).
;|***  */
;|*** #define SS_TEXT 		0x0001L
;|*** #define SS_GROUPBOX		0x0002L
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define SS_ICON 		0x0003L
;|*** #define SS_BITMAP		0x0004L
;|*** #endif /* !INCL_SAADEFS */
;|*** #define SS_FGNDRECT		0x0005L
;|*** #ifndef INCL_SAADEFS
;|*** #define SS_HALFTONERECT 	0x0006L
;|*** #endif /* !INCL_SAADEFS */
;|*** #define SS_BKGNDRECT		0x0007L
;|*** #define SS_FGNDFRAME		0x0008L
;|*** #ifndef INCL_SAADEFS
;|*** #define SS_HALFTONEFRAME	0x0009L
;|*** #endif /* !INCL_SAADEFS */
;|*** #define SS_BKGNDFRAME		0x000aL
;|*** #define SS_SYSICON		0x000bL
;|*** 
;|*** /* Static control class name */
;|*** 
;|*** #define WC_STATIC		((PSZ)0xffff0005L)
;|*** 
;|*** /* Static control messages */
;|*** 
;|*** #define SM_SETHANDLE		0x0100
;|*** #define SM_QUERYHANDLE		0x0101
;|*** 
;|*** #endif /* INCL_WINSTATICS */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINBUTTONS) && !defined(INCL_WINBUTTONS_INCLUDED))
;|*** #define INCL_WINBUTTONS_INCLUDED
;|*** /**** Button Controls Subsection */
;|*** 
;|*** /* Button control styles */
;|*** 
;|*** #define BS_PUSHBUTTON		0L
;|*** #define BS_CHECKBOX		1L
;|*** #define BS_AUTOCHECKBOX 	2L
;|*** #define BS_RADIOBUTTON		3L
;|*** #define BS_AUTORADIOBUTTON	4L
;|*** #define BS_3STATE		5L
;|*** #define BS_AUTO3STATE		6L
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define BS_USERBUTTON		7L
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define BS_HELP 		0x0100L
;|*** #define BS_SYSCOMMAND		0x0200L
;|*** #define BS_DEFAULT		0x0400L
;|*** #define BS_NOPOINTERFOCUS	0x0800L
;|*** #define BS_NOBORDER		0x1000L
;|*** #define BS_NOCURSORSELECT	0x2000L
;|*** 
;|*** 
;|*** /* Button class name */
;|*** 
;|*** #define WC_BUTTON	 ((PSZ)0xffff0003L)
;|*** 
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** typedef struct _BTNCDATA { /* btncd */
;|*** 	USHORT	cb;
;|*** 	USHORT	fsCheckState;
;|*** 	USHORT	fsHiliteState;
;|*** } BTNCDATA;
;|*** typedef BTNCDATA FAR *PBTNCDATA;
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /* User button structure (passed in WM_CONTROL msg) */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** typedef struct _USERBUTTON { /* ubtn */
;|*** 	HWND	hwnd;
;|*** 	HPS	hps;
;|*** 	USHORT	fsState;
;|*** 	USHORT	fsStateOld;
;|*** } USERBUTTON;
;|*** typedef USERBUTTON FAR *PUSERBUTTON;
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /* Button control messages */
;|*** 
;|*** #define BM_CLICK		0x0120
;|*** #define BM_QUERYCHECKINDEX	0x0121
;|*** #define BM_QUERYHILITE		0x0122
;|*** #define BM_SETHILITE		0x0123
;|*** #define BM_QUERYCHECK		0x0124
;|*** #define BM_SETCHECK		0x0125
;|*** #define BM_SETDEFAULT		0x0126
;|*** 
;|*** /* Button notification codes */
;|*** 
;|*** #define BN_CLICKED		1
;|*** #define BN_DBLCLICKED		2
;|*** #define BN_PAINT		3
;|*** 
;|*** /* BN_PAINT button draw state codes (must be in high byte) */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define BDS_HILITED		0x0100
;|*** #define BDS_DISABLED		0x0200
;|*** #define BDS_DEFAULT		0x0400
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINBUTTONS */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINENTRYFIELDS) && !defined(INCL_WINENTRYFIELDS_INCLUDED))
;|*** #define INCL_WINENTRYFIELDS_INCLUDED
;|*** /**** Entryfield controls Subsection */
;|*** 
;|*** /* Entry field  styles */
;|*** 
;|*** #define ES_LEFT 		0x00000000L
;|*** #define ES_CENTER		0x00000001L
;|*** #define ES_RIGHT		0x00000002L
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define ES_AUTOSCROLL		0x00000004L
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define ES_MARGIN		0x00000008L
;|*** #define ES_AUTOTAB		0x00000010L
;|*** #define ES_READONLY		0x00000020L
;|*** #define ES_COMMAND		0x00000040L
;|*** #define ES_UNREADABLE		0x00000080L
;|*** #define ES_PICTUREMASK		0x00000100L
;|*** 
;|*** #ifdef INCL_NLS
;|*** #define ES_ANY			0x00000000L
;|*** #define ES_SBCS 		0x00100000L
;|*** #define ES_DBCS 		0x00200000L
;|*** #define ES_MIXED		0x00300000L
;|*** #endif /* INCL_NLS */
;|*** 
;|*** #define WC_COMBOBOX		((PSZ)0xffff0002L)
;|*** 
;|*** /*
;|***  * combo box styles
;|***  */
;|*** #define CBS_SIMPLE		0x0001L
;|*** #define CBS_DROPDOWN		0x0002L
;|*** #define CBS_DROPDOWNLIST	0x0004L
;|*** 
;|*** #define CBM_SHOWLIST		0x0170L
;|*** #define CBM_HILITE		0x0171L
;|*** #define CBM_ISLISTSHOWING	0x0172L
;|*** 
;|*** #define CBN_EFCHANGE		1
;|*** #define CBN_EFSCROLL		2
;|*** #define CBN_MEMERROR		3
;|*** #define CBN_LBSELECT		4
;|*** #define CBN_LBSCROLL		5
;|*** #define CBN_SHOWLIST		6
;|*** #define CBN_ENTER		7
;|*** 
;|*** #define WC_ENTRYFIELD		((PSZ)0xffff0006L)
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** typedef struct _ENTRYFDATA { /* efd */
;|***     USHORT  cb;
;|***     USHORT  cchEditLimit;
;|***     USHORT  ichMinSel;
;|***     USHORT  ichMaxSel;
;|*** } ENTRYFDATA;
;|*** typedef ENTRYFDATA FAR *PENTRYFDATA;
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /* Entry Field  messages */
;|*** 
;|*** #define EM_QUERYCHANGED 	0x0140
;|*** #define EM_QUERYSEL		0x0141
;|*** #define EM_SETSEL		0x0142
;|*** #define EM_SETTEXTLIMIT 	0x0143
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define EM_CUT			0x0144
;|*** #define EM_COPY 		0x0145
;|*** #endif /* !INCL_SAADEFS */
;|*** #define EM_CLEAR		0x0146
;|*** #ifndef INCL_SAADEFS
;|*** #define EM_PASTE		0x0147
;|*** #endif /* !INCL_SAADEFS */
;|*** #define EM_QUERYFIRSTCHAR	0x0148
;|*** #define EM_SETFIRSTCHAR 	0x0149
;|*** #ifndef INCL_SAADEFS
;|*** #define EM_QUERYREADONLY	0x014a
;|*** #define EM_SETREADONLY		0x014b
;|*** #define EM_SETINSERTMODE	0x014c
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /* Entry Field notification messages */
;|*** 
;|*** #define EN_SETFOCUS		0x0001
;|*** #define EN_KILLFOCUS		0x0002
;|*** #define EN_CHANGE		0x0004
;|*** #define EN_SCROLL		0x0008
;|*** #ifndef INCL_SAADEFS
;|*** #define EN_MEMERROR		0x0010
;|*** #define EN_OVERFLOW		0x0020
;|*** #define EN_INSERTMODETOGGLE	0x0040
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINENTRYFIELDS */
;|*** 
;|*** 
;|*** /*  Multiple Line Entrys */
;|*** #if (defined(INCL_WINMLE) && !defined(PMMLE_INCLUDED))
;|*** #define WC_MLE	((PSZ)0xffff000aL)
;|*** #include <pmmle.h>
;|*** #endif /* !INCL_WINMLE */
;|*** 
;|*** #if (defined(INCL_WINLISTBOXES) && !defined(INCL_WINLISTBOXES_INCLUDED))
;|*** #define INCL_WINLISTBOXES_INCLUDED
;|*** 
;|*** /**** Listboxes */
;|*** 
;|*** /* List box styles */
;|*** 
;|*** #define LS_MULTIPLESEL		0x00000001L
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define LS_OWNERDRAW		0x00000002L
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define LS_NOADJUSTPOS		0x00000004L
;|*** #define LS_HORZSCROLL		0x00000008L
;|*** 
;|*** 
;|*** /* Listbox class name */
;|*** 
;|*** #define WC_LISTBOX		((PSZ)0xffff0007L)
;|*** 
;|*** /* List box notification messages */
;|*** 
;|*** #define LN_SELECT		1
;|*** #define LN_SETFOCUS		2
;|*** #define LN_KILLFOCUS		3
;|*** #define LN_SCROLL		4
;|*** #define LN_ENTER		5
;|*** 
;|*** /* List box messages */
;|*** 
;|*** #define LM_QUERYITEMCOUNT	0x0160
;|*** #define LM_INSERTITEM		0x0161
;|*** #define LM_SETTOPINDEX		0x0162
;|*** #define LM_DELETEITEM		0x0163
;|*** #define LM_SELECTITEM		0x0164
;|*** #define LM_QUERYSELECTION	0x0165
;|*** #define LM_SETITEMTEXT		0x0166
;|*** #define LM_QUERYITEMTEXTLENGTH	0x0167
;|*** #define LM_QUERYITEMTEXT	0x0168
;|*** 
;|*** #define LM_SETITEMHANDLE	0x0169
;|*** #define LM_QUERYITEMHANDLE	0x016a
;|*** #define LM_SEARCHSTRING 	0x016b
;|*** #define LM_SETITEMHEIGHT	0x016c
;|*** #define LM_QUERYTOPINDEX	0x016d
;|*** #define LM_DELETEALL		0x016e
;|*** 
;|*** /* List box constants */
;|*** 
;|*** #define LIT_ERROR		(-3)
;|*** #define LIT_MEMERROR		(-2)
;|*** #define LIT_NONE		(-1)
;|*** #define LIT_FIRST		(-1)
;|*** 
;|*** /* For LM_INSERTITEM msg */
;|*** 
;|*** #define LIT_END 		(-1)
;|*** #define LIT_SORTASCENDING	(-2)
;|*** #define LIT_SORTDESCENDING	(-3)
;|*** 
;|*** /* For LM_SEARCHSTRING msg */
;|*** 
;|*** #define LSS_SUBSTRING		0x0001
;|*** #define LSS_PREFIX		0x0002
;|*** #define LSS_CASESENSITIVE	0x0004
;|*** 
;|*** 
;|*** #endif /* INCL_WINLISTBOXES */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINMENUS) && !defined(INCL_WINMENUS_INCLUDED))
;|*** #define INCL_WINMENUS_INCLUDED
;|*** 
;|*** /**** Menu Manager Subsection */
;|*** 
;|*** /* Menu control styles */
;|*** 
;|*** #define MS_ACTIONBAR		0x00000001L
;|*** #define MS_TITLEBUTTON		0x00000002L
;|*** #define MS_VERTICALFLIP 	0x00000004L
;|*** 
;|*** HWND APIENTRY WinLoadMenu(HWND hwndFrame, HMODULE hmod, USHORT idMenu);
;|*** 
;|*** /* Menu class name */
;|*** 
;|*** #define WC_MENU              ((PSZ)0xffff0004L)
;|*** 
;|*** /* Menu control messages */
;|*** 
;|*** #define MM_INSERTITEM		0x0180
;|*** #define MM_DELETEITEM		0x0181
;|*** #define MM_QUERYITEM		0x0182
;|*** #define MM_SETITEM		0x0183
;|*** #define MM_QUERYITEMCOUNT	0x0184
;|*** #define MM_STARTMENUMODE	0x0185
;|*** #define MM_ENDMENUMODE		0x0186
;|*** #define MM_DISMISSMENU		0x0187
;|*** #define MM_REMOVEITEM		0x0188
;|*** #define MM_SELECTITEM		0x0189
;|*** #define MM_QUERYSELITEMID	0x018a
;|*** #define MM_QUERYITEMTEXT	0x018b
;|*** #define MM_QUERYITEMTEXTLENGTH	0x018c
;|*** #define MM_SETITEMHANDLE	0x018d
;|*** #define MM_SETITEMTEXT		0x018e
;|*** #define MM_ITEMPOSITIONFROMID	0x018f
;|*** #define MM_ITEMIDFROMPOSITION	0x0190
;|*** #define MM_QUERYITEMATTR	0x0191
;|*** #define MM_SETITEMATTR		0x0192
;|*** #define MM_ISITEMVALID		0x0193
;|*** 
;|*** HWND APIENTRY WinCreateMenu(HWND hwndParent, PVOID pvmt);
;|*** 
;|*** /* Owner Item Structure (Also used for listboxes) */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** typedef struct _OWNERITEM { /* oi */
;|*** 	HWND	hwnd;
;|*** 	HPS	hps;
;|*** 	USHORT	fsState;
;|*** 	USHORT	fsAttribute;
;|*** 	USHORT	fsStateOld;
;|*** 	USHORT	fsAttributeOld;
;|*** 	RECTL	rclItem;
;|*** 	SHORT	idItem; /* This field contains idItem for menus, iItem for lb. */
;|*** 	ULONG	hItem;
;|*** } OWNERITEM;
;|*** typedef OWNERITEM FAR *POWNERITEM;
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /* Menu item */
;|*** 
;|*** typedef struct _MENUITEM { /* mi */
;|*** 	SHORT	iPosition;
;|*** 	USHORT	afStyle;
;|*** 	USHORT	afAttribute;
;|*** 	USHORT	id;
;|*** 	HWND	hwndSubMenu;
;|*** 	ULONG	hItem;
;|*** } MENUITEM;
;|*** typedef MENUITEM FAR *PMENUITEM;
;|*** 
;|*** #define MIT_END 		(-1)
;|*** #define MIT_NONE		(-1)
;|*** #define MIT_MEMERROR		(-1)
;|*** #define MIT_ERROR		(-1)
;|*** #define MID_NONE		MIT_NONE
;|*** #define MID_ERROR		(-1)
;|*** 
;|*** /* Menu item styles & attributes */
;|*** 
;|*** #define MIS_TEXT		0x0001
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define MIS_BITMAP		0x0002
;|*** #endif /* !INCL_SAADEFS */
;|*** #define MIS_SEPARATOR		0x0004
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define MIS_OWNERDRAW		0x0008
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define MIS_SUBMENU		0x0010
;|*** #define MIS_MULTMENU		0x0020	    /* multiple choice submenu	   */
;|*** #define MIS_SYSCOMMAND		0x0040
;|*** #define MIS_HELP		0x0080
;|*** #define MIS_STATIC		0x0100
;|*** #define MIS_BUTTONSEPARATOR	0x0200
;|*** #define MIS_BREAK		0x0400
;|*** #define MIS_BREAKSEPARATOR	0x0800
;|*** #define MIS_GROUP		0x1000	    /* multiple choice group start */
;|*** /* In multiple choice submenus a style of 'single' denotes the item is a
;|*** ** radiobutton.  Absence of this style defaults the item to a checkbox.    */
;|*** #define MIS_SINGLE                 0x2000
;|*** 
;|*** #define MIA_NODISMISS		0x0020
;|*** #define MIA_FRAMED		0x1000
;|*** #define MIA_CHECKED		0x2000
;|*** #define MIA_DISABLED		0x4000
;|*** #define MIA_HILITED		0x8000
;|*** 
;|*** #endif /* INCL_WINMENUS */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINSCROLLBARS) && !defined(INCL_WINSCROLLBARS_INCLUDED))
;|*** #define INCL_WINSCROLLBARS_INCLUDED
;|*** 
;|*** /*** Scroll Bar controls Subsection */
;|*** 
;|*** /* Scroll Bar styles */
;|*** 
;|*** #define SBS_HORZ		0L
;|*** #define SBS_VERT		1L
;|*** #define SBS_THUMBSIZE		2L
;|*** #define SBS_AUTOTRACK		4L
;|*** 
;|*** /* Scroll bar class name */
;|*** 
;|*** 
;|*** #define WC_SCROLLBAR         ((PSZ)0xffff0008L)
;|*** 
;|*** /* Scroll Bar messages */
;|*** 
;|*** #define SBM_SETSCROLLBAR	0x01a0
;|*** #define SBM_SETPOS		0x01a1
;|*** #define SBM_QUERYPOS		0x01a2
;|*** #define SBM_QUERYRANGE		0x01a3
;|*** #define SBM_SETHILITE		0x01a4
;|*** #define SBM_QUERYHILITE 	0x01a5
;|*** #define SBM_SETTHUMBSIZE	0x01a6
;|*** 
;|*** /* Scroll Bar Commands */
;|*** 
;|*** #define SB_LINEUP		1
;|*** #define SB_LINEDOWN		2
;|*** #define SB_LINELEFT		1
;|*** #define SB_LINERIGHT		2
;|*** #define SB_PAGEUP		3
;|*** #define SB_PAGEDOWN		4
;|*** #define SB_PAGELEFT		3
;|*** #define SB_PAGERIGHT		4
;|*** #define SB_SLIDERTRACK		5
;|*** #define SB_SLIDERPOSITION	6
;|*** #define SB_ENDSCROLL		7
;|*** 
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** typedef struct _SBCDATA { /* sbcd */
;|*** 	USHORT	cb;
;|*** 	USHORT	sHilite;      /* reserved, should be set to zero */
;|*** 	SHORT	posFirst;
;|*** 	SHORT	posLast;
;|*** 	SHORT	posThumb;
;|*** 	SHORT	cVisible;
;|*** 	SHORT	cTotal;
;|*** } SBCDATA;
;|*** typedef SBCDATA FAR *PSBCDATA;
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINSCROLLBARS */
;|*** 
;|*** 
;|*** #if ((defined(INCL_WINFRAMEMGR) || !defined(INCL_NOCOMMON)) && !defined(INCL_WINFRAMEMGR_INCLUDED))
;|*** 
;|*** /*** Frame Manager Common subsection */
;|*** 
;|*** typedef struct _FRAMECDATA { /* fcdata */
;|*** 	USHORT	cb;
;|*** 	ULONG	flCreateFlags;
;|*** 	HMODULE hmodResources;
;|*** 	USHORT	idResources;
;|*** } FRAMECDATA;
;|*** typedef FRAMECDATA FAR *PFRAMECDATA;
;|*** 
;|*** /* Frame window styles */
;|*** 
;|*** #define FCF_TITLEBAR		0x00000001L
;|*** #define FCF_SYSMENU		0x00000002L
;|*** #define FCF_MENU		0x00000004L
;|*** #define FCF_SIZEBORDER		0x00000008L
;|*** #define FCF_MINBUTTON		0x00000010L
;|*** #define FCF_MAXBUTTON		0x00000020L
;|*** #define FCF_MINMAX		0x00000030L /* minmax means BOTH buttons */
;|*** #define FCF_VERTSCROLL		0x00000040L
;|*** #define FCF_HORZSCROLL		0x00000080L
;|*** #define FCF_DLGBORDER		0x00000100L
;|*** #define FCF_BORDER		0x00000200L
;|*** #define FCF_SHELLPOSITION	0x00000400L
;|*** #define FCF_TASKLIST		0x00000800L
;|*** #define FCF_NOBYTEALIGN 	0x00001000L
;|*** #define FCF_NOMOVEWITHOWNER	0x00002000L
;|*** #define FCF_ICON		0x00004000L
;|*** #define FCF_ACCELTABLE		0x00008000L
;|*** #define FCF_SYSMODAL		0x00010000L
;|*** #define FCF_SCREENALIGN 	0x00020000L
;|*** #define FCF_MOUSEALIGN		0x00040000L
;|*** /* New values to enable multiple palettes.  Note that if none of the four  */
;|*** /* styles specified below are used then we default to the 'system' palette */
;|*** #define FCF_PALETTE_NORMAL	0x00080000L /* normal palette		   */
;|*** #define FCF_PALETTE_HELP	0x00100000L /* help palette		   */
;|*** #define FCF_PALETTE_POPUPODD	0x00200000L /* odd level popup palette	   */
;|*** #define FCF_PALETTE_POPUPEVEN	0x00400000L /* even level popup palette    */
;|*** /* FCF_ 0x00800000L is reserved */
;|*** #ifdef INCL_NLS
;|*** #define FCF_DBE_APPSTAT 	0x80000000L
;|*** #endif /* INCL_NLS */
;|*** 
;|*** /* FCF_TITLEBAR | FCF_SYSMENU | FCF_MENU | FCF_SIZEBORDER | FCF_MINMAX |
;|***    FCF_ICON | FCF_ACCELTABLE | FCF_SHELLPOSITION | FCF_TASKLIST | FCF_PALETTE_NORMAL */
;|*** #define FCF_STANDARD		0x0008CC3FL
;|*** 
;|*** 
;|*** #define FS_ICON 		0x00000001L
;|*** #define FS_ACCELTABLE		0x00000002L
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define FS_SHELLPOSITION	0x00000004L
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define FS_TASKLIST		0x00000008L
;|*** #define FS_NOBYTEALIGN		0x00000010L
;|*** #define FS_NOMOVEWITHOWNER	0x00000020L
;|*** #define FS_SYSMODAL		0x00000040L
;|*** #define FS_DLGBORDER		0x00000080L
;|*** #define FS_BORDER		0x00000100L
;|*** #define FS_SCREENALIGN		0x00000200L
;|*** #define FS_MOUSEALIGN		0x00000400L
;|*** #define FS_SIZEBORDER		0x00000800L
;|*** #ifdef INCL_NLS
;|*** #define FS_DBE_APPSTAT		0x00008000L
;|*** #endif /* INCL_NLS */
;|*** 
;|*** /* FS_ICON | FS_ACCELTABLE | FS_SHELLPOSITION | FS_TASKLIST */
;|*** #define FS_STANDARD		0x0000000FL
;|*** 
;|*** 
;|*** /* Frame Window Flags accessed via WinSet/QueryWindowUShort(QWS_FLAGS) */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define FF_FLASHWINDOW		0x0001
;|*** #define FF_ACTIVE		0x0002
;|*** #define FF_FLASHHILITE		0x0004
;|*** #define FF_OWNERHIDDEN		0x0008
;|*** #define FF_DLGDISMISSED 	0x0010
;|*** #define FF_OWNERDISABLED	0x0020
;|*** #define FF_SELECTED		0x0040
;|*** #define FF_NOACTIVATESWP	0x0080
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** 
;|*** HWND APIENTRY WinCreateStdWindow(HWND hwndParent, ULONG flStyle,
;|*** 				 PULONG pflCreateFlags, PSZ pszClientClass,
;|*** 				 PSZ pszTitle, ULONG flClientStyle,
;|*** 				 HMODULE hmod, USHORT idResources,
;|*** 				 PHWND phwndClient);
;|*** 
;|*** 
;|*** #endif /* Frame Manager Common subsection */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINFRAMEMGR) && !defined(INCL_WINFRAMEMGR_INCLUDED))
;|*** #define INCL_WINFRAMEMGR_INCLUDED
;|*** 
;|*** BOOL  APIENTRY WinFlashWindow(HWND hwndFrame, BOOL fFlash);
;|*** 
;|*** /* Frame window related messages */
;|*** 
;|*** #define WM_FLASHWINDOW		0x0040
;|*** #define WM_FORMATFRAME		0x0041
;|*** #define WM_UPDATEFRAME		0x0042
;|*** #define WM_FOCUSCHANGE		0x0043
;|*** 
;|*** #define WM_SETBORDERSIZE	0x0044
;|*** #define WM_TRACKFRAME		0x0045
;|*** #define WM_MINMAXFRAME		0x0046
;|*** #define WM_SETICON		0x0047
;|*** #define WM_QUERYICON		0x0048
;|*** #define WM_SETACCELTABLE	0x0049
;|*** #define WM_QUERYACCELTABLE	0x004a
;|*** #define WM_TRANSLATEACCEL	0x004b
;|*** #define WM_QUERYTRACKINFO	0x004c
;|*** #define WM_QUERYBORDERSIZE	0x004d
;|*** #define WM_NEXTMENU		0x004e
;|*** #define WM_ERASEBACKGROUND	0x004f
;|*** #define WM_QUERYFRAMEINFO	0x0050
;|*** /* Note 0x0051/5 are reserved */
;|*** #define WM_QUERYFOCUSCHAIN	0x0051
;|*** #define WM_CALCFRAMERECT	0x0053
;|*** #define WM_WINDOWPOSCHANGED	0x0055
;|*** #define WM_QUERYFRAMECTLCOUNT	0x0059
;|*** #ifndef INCL_SAADEFS
;|*** /* Note 0x005A is reserved */
;|*** #define WM_QUERYHELPINFO	0x005B
;|*** #define WM_SETHELPINFO		0x005C
;|*** #define WM_ERROR		0x005D
;|*** 
;|*** 
;|*** /* WM_QUERYFRAMEINFO constants */
;|*** 
;|*** #define FI_FRAME		0x00000001L
;|*** #define FI_OWNERHIDE		0x00000002L
;|*** #define FI_ACTIVATEOK		0x00000004L
;|*** #define FI_NOMOVEWITHOWNER	0x00000008L
;|*** 
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /* Frame class name */
;|*** 
;|*** #define WC_FRAME		((PSZ)0xffff0001L)
;|*** 
;|*** BOOL  APIENTRY WinCreateFrameControls(HWND hwndFrame, PFRAMECDATA pfcdata,
;|*** 				      PSZ pszTitle);
;|*** 
;|*** BOOL  APIENTRY WinCalcFrameRect(HWND hwndFrame, PRECTL prcl, BOOL fClient);
;|*** 
;|*** BOOL  APIENTRY WinGetMinPosition(HWND hwnd, PSWP pswp, PPOINTL pptl);
;|*** #ifndef INCL_SAADEFS
;|*** BOOL  APIENTRY WinGetMaxPosition(HWND hwnd, PSWP pswp);
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** SHORT APIENTRY WinFormatFrame(HWND hwndFrame, PRECTL prclFrame, PSWP pswp,
;|***                               USHORT cswpMax, PRECTL prclClient);
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** /* Frame control IDs    */
;|*** 
;|*** #define FID_SYSMENU		0x8002
;|*** #define FID_TITLEBAR		0x8003
;|*** #define FID_MINMAX		0x8004
;|*** #define FID_MENU		0x8005
;|*** #define FID_VERTSCROLL		0x8006
;|*** #define FID_HORZSCROLL		0x8007
;|*** #define FID_CLIENT		0x8008
;|*** /* Note 0x8009 is reserved */
;|*** #define FID_DBE_APPSTAT 	0x8010
;|*** #define FID_DBE_KBDSTAT 	0x8011
;|*** #define FID_DBE_PECIC		0x8012
;|*** #define FID_DBE_KKPOPUP 	0x8013
;|*** 
;|*** /* Standard WM_SYSCOMMAND command values */
;|*** 
;|*** #define SC_SIZE 		0x8000
;|*** #define SC_MOVE 		0x8001
;|*** #define SC_MINIMIZE		0x8002
;|*** #define SC_MAXIMIZE		0x8003
;|*** #define SC_CLOSE		0x8004
;|*** #define SC_NEXT 		0x8005
;|*** #define SC_APPMENU		0x8006
;|*** #define SC_SYSMENU		0x8007
;|*** #define SC_RESTORE		0x8008
;|*** #define SC_NEXTFRAME		0x8009
;|*** #define SC_NEXTWINDOW		0x8010
;|*** #ifndef INCL_SAADEFS
;|*** #define SC_TASKMANAGER		0x8011
;|*** #define SC_HELPKEYS		0x8012
;|*** #define SC_HELPINDEX		0x8013
;|*** #define SC_HELPEXTENDED 	0x8014
;|*** #define SC_SWITCHPANELIDS	0x8015
;|*** #define SC_DBE_FIRST		0x8018
;|*** #define SC_DBE_LAST		0x801F
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINFRAMEMGR */
;|*** 
;|*** /*** Frame controls */
;|*** 
;|*** #if (defined(INCL_WINFRAMECTLS) && !defined(INCL_WINFRAMECTLS_INCLUDED))
;|*** #define INCL_WINFRAMECTLS_INCLUDED
;|*** 
;|*** /** Title bar controls */
;|*** 
;|*** /* Title bar control class name */
;|*** 
;|*** #define WC_TITLEBAR		((PSZ)0xffff0009L)
;|*** 
;|*** /* Title bar control messages */
;|*** 
;|*** #define TBM_SETHILITE		0x01e3
;|*** #define TBM_QUERYHILITE 	0x01e4
;|*** #define TBM_TRACKMOVE		0x01e5
;|*** 
;|*** #endif /* INCL_WINFRAMECTLS */
;|*** 
;|*** #if (defined(INCL_WINRECTANGLES) && !defined(INCL_WINRECTANGLES_INCLUDED))
;|*** #define INCL_WINRECTANGLES_INCLUDED
;|*** /*** Rectangle routines */
;|*** 
;|*** BOOL APIENTRY WinCopyRect(HAB hab, PRECTL prclDst, PRECTL prclSrc);
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** BOOL APIENTRY WinSetRect(HAB hab, PRECTL prcl, SHORT xLeft, SHORT yBottom,
;|*** 			 SHORT xRight, SHORT yTop);
;|*** BOOL APIENTRY WinIsRectEmpty(HAB hab, PRECTL prcl);
;|*** BOOL APIENTRY WinEqualRect(HAB hab, PRECTL prcl1, PRECTL prcl2);
;|*** BOOL APIENTRY WinSetRectEmpty(HAB hab, PRECTL prcl);
;|*** BOOL APIENTRY WinOffsetRect(HAB hab, PRECTL prcl, SHORT cx, SHORT cy);
;|*** BOOL APIENTRY WinInflateRect(HAB hab, PRECTL prcl, SHORT cx, SHORT cy);
;|*** BOOL APIENTRY WinPtInRect(HAB hab, PRECTL prcl, PPOINTL pptl);
;|*** BOOL APIENTRY WinIntersectRect(HAB hab, PRECTL prclDst, PRECTL prclSrc1,
;|*** 			       PRECTL prclSrc2);
;|*** BOOL APIENTRY WinUnionRect(HAB hab, PRECTL prclDst, PRECTL prclSrc1,
;|*** 			   PRECTL prclSrc2);
;|*** BOOL APIENTRY WinSubtractRect(HAB hab, PRECTL prclDst, PRECTL prclSrc1,
;|*** 			      PRECTL prclSrc2);
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINRECTANGLES */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINSYS) && !defined(INCL_WINSYS_INCLUDED))
;|*** #define INCL_WINSYS_INCLUDED
;|*** 
;|*** /*** System values */
;|*** 
;|*** LONG APIENTRY WinQuerySysValue(HWND hwndDesktop, SHORT iSysValue);
;|*** BOOL  APIENTRY WinSetSysValue(HWND hwndDesktop, SHORT iSysValue, LONG lValue);
;|*** 
;|*** #define SV_SWAPBUTTON		0
;|*** #define SV_DBLCLKTIME		1
;|*** #define SV_CXDBLCLK		2
;|*** #define SV_CYDBLCLK		3
;|*** #define SV_CXSIZEBORDER 	4
;|*** #define SV_CYSIZEBORDER 	5
;|*** #define SV_ALARM		6
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define SV_RESERVEDFIRST1	7
;|*** #define SV_RESERVEDLAST1	8
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define SV_CURSORRATE		9
;|*** #define SV_FIRSTSCROLLRATE	10
;|*** #define SV_SCROLLRATE		11
;|*** #define SV_NUMBEREDLISTS	12
;|*** #define SV_WARNINGFREQ		13
;|*** #define SV_NOTEFREQ		14
;|*** #define SV_ERRORFREQ		15
;|*** #define SV_WARNINGDURATION	16
;|*** #define SV_NOTEDURATION 	17
;|*** #define SV_ERRORDURATION	18
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define SV_RESERVEDFIRST	19
;|*** #define SV_RESERVEDLAST 	19
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define SV_CXSCREEN		20
;|*** #define SV_CYSCREEN		21
;|*** #define SV_CXVSCROLL		22
;|*** #define SV_CYHSCROLL		23
;|*** #define SV_CYVSCROLLARROW	24
;|*** #define SV_CXHSCROLLARROW	25
;|*** #define SV_CXBORDER		26
;|*** #define SV_CYBORDER		27
;|*** #define SV_CXDLGFRAME		28
;|*** #define SV_CYDLGFRAME		29
;|*** #define SV_CYTITLEBAR		30
;|*** #define SV_CYVSLIDER		31
;|*** #define SV_CXHSLIDER		32
;|*** #define SV_CXMINMAXBUTTON	33
;|*** #define SV_CYMINMAXBUTTON	34
;|*** #define SV_CYMENU		35
;|*** #define SV_CXFULLSCREEN 	36
;|*** #define SV_CYFULLSCREEN 	37
;|*** #define SV_CXICON		38
;|*** #define SV_CYICON		39
;|*** #define SV_CXPOINTER		40
;|*** #define SV_CYPOINTER		41
;|*** 
;|*** #define SV_DEBUG		42
;|*** #define SV_CMOUSEBUTTONS	43
;|*** #define SV_POINTERLEVEL 	44
;|*** #define SV_CURSORLEVEL		45
;|*** #define SV_TRACKRECTLEVEL	46
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define SV_CTIMERS		47
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #define SV_MOUSEPRESENT 	48
;|*** 
;|*** #define SV_CXBYTEALIGN		49
;|*** #define SV_CYBYTEALIGN		50
;|*** 
;|*** /* The following value enables any greater value to be set by WinSetSysVlaue. */
;|*** /* Values of 51-55 are spare for extra non-settable system values             */
;|*** /* This is to enable the setting of SV_EXTRAKEYBEEP by applications.          */
;|*** 
;|*** #define SV_NOTRESERVED		56
;|*** #define SV_EXTRAKEYBEEP 	57
;|*** 
;|*** /* The following system value controls whether PM controls the keyboard      */
;|*** /* lights for light key keystrokes (else applications will)                  */
;|*** #define SV_SETLIGHTS		58
;|*** #define SV_INSERTMODE		59
;|*** 
;|*** 
;|*** #define SV_MENUROLLDOWNDELAY	64
;|*** #define SV_MENUROLLUPDELAY	65
;|*** #define SV_ALTMNEMONIC		66
;|*** #define SV_TASKLISTMOUSEACCESS	67
;|*** /* The following is the total number of system values */
;|*** #define SV_CSYSVALUES		68
;|*** 
;|*** #define SV_CPOINTERBUTTONS	69
;|*** #define SV_CXALIGN		70
;|*** #define SV_CYALIGN		71
;|*** #define SV_MNEMONICSENABLED	72
;|*** 
;|*** /*
;|***  * Presentation parameter structures.
;|***  */
;|*** typedef struct _PARAM { /* param */
;|*** 	ULONG	id;
;|*** 	ULONG	cb;
;|*** 	BYTE	ab[1];
;|*** } PARAM;
;|*** typedef PARAM NEAR *NPPARAM;
;|*** typedef PARAM FAR  *PPARAM;
;|*** 
;|*** typedef struct _PRESPARAMS { /* pres */
;|*** 	ULONG	cb;
;|*** 	PARAM	aparam[1];
;|*** } PRESPARAMS;
;|*** typedef PRESPARAMS NEAR *NPPRESPARAMS;
;|*** typedef PRESPARAMS FAR  *PPRESPARAMS;
;|*** 
;|*** 
;|*** /*
;|***  * Presentation parameter APIs
;|***  */
;|*** BOOL  APIENTRY WinSetPresParam(HWND hwnd, ULONG id, ULONG cbParam,
;|*** 			       PVOID pbParam);
;|*** ULONG APIENTRY WinQueryPresParam(HWND hwnd, ULONG id1, ULONG id2,
;|*** 				 PULONG pulId, ULONG cbBuf, PVOID pbBuf,
;|*** 				 USHORT fs);
;|*** BOOL  APIENTRY WinRemovePresParam(HWND hwnd, ULONG id);
;|*** 
;|*** /*
;|***  * Presentation parameter types.
;|***  */
;|*** 
;|*** #define PP_FOREGROUNDCOLOR		 1L
;|*** #define PP_FOREGROUNDCOLORINDEX 	 2L
;|*** #define PP_BACKGROUNDCOLOR		 3L
;|*** #define PP_BACKGROUNDCOLORINDEX 	 4L
;|*** #define PP_HILITEFOREGROUNDCOLOR	 5L
;|*** #define PP_HILITEFOREGROUNDCOLORINDEX	 6L
;|*** #define PP_HILITEBACKGROUNDCOLOR	 7L
;|*** #define PP_HILITEBACKGROUNDCOLORINDEX	 8L
;|*** #define PP_DISABLEDFOREGROUNDCOLOR	 9L
;|*** #define PP_DISABLEDFOREGROUNDCOLORINDEX  10L
;|*** #define PP_DISABLEDBACKGROUNDCOLOR	 11L
;|*** #define PP_DISABLEDBACKGROUNDCOLORINDEX  12L
;|*** #define PP_BORDERCOLOR			 13L
;|*** #define PP_BORDERCOLORINDEX		 14L
;|*** #define PP_FONTNAMESIZE 		 15L
;|*** #define PP_FONTHANDLE			 16L
;|*** 
;|*** /*
;|***  * Flags for WinQueryPresParams()
;|***  */
;|*** #define QPF_NOINHERIT	   0x0001 /* Don't inherit                      */
;|*** #define QPF_ID1COLORINDEX  0x0002 /* Convert id1 color index into RGB	*/
;|*** #define QPF_ID2COLORINDEX  0x0004 /* Convert id2 color index into RGB	*/
;|*** #define QPF_PURERGBCOLOR   0x0008 /* Return pure RGB colors		*/
;|*** #define QPF_VALIDFLAGS	   0x000F /* Valid WinQueryPresParams() flags.	*/
;|*** 
;|*** /*** System color functions */
;|*** 
;|*** LONG APIENTRY WinQuerySysColor(HWND hwndDesktop, COLOR clr, LONG lReserved);
;|*** BOOL APIENTRY WinSetSysColors(HWND hwndDesktop, ULONG flOptions,
;|*** 			      ULONG flFormat, COLOR clrFirst, ULONG cclr,
;|*** 			      PCOLOR pclr);
;|*** #define SYSCLR_BUTTONLIGHT		(-41L)
;|*** #define SYSCLR_BUTTONMIDDLE		(-40L)
;|*** #define SYSCLR_BUTTONDARK		(-39L)
;|*** #define SYSCLR_BUTTONDEFAULT		(-38L)
;|*** #define SYSCLR_TITLEBOTTOM		(-37L)
;|*** #define SYSCLR_SHADOW			(-36L)
;|*** #define SYSCLR_ICONTEXT 		(-35L)
;|*** #define SYSCLR_DIALOGBACKGROUND 	(-34L)
;|*** #define SYSCLR_HILITEFOREGROUND 	(-33L)
;|*** #define SYSCLR_HILITEBACKGROUND 	(-32L)
;|*** #define SYSCLR_INACTIVETITLETEXTBGND	(-31L)
;|*** #define SYSCLR_ACTIVETITLETEXTBGND	(-30L)
;|*** #define SYSCLR_INACTIVETITLETEXT	(-29L)
;|*** #define SYSCLR_ACTIVETITLETEXT		(-28L)
;|*** #define SYSCLR_OUTPUTTEXT		(-27L)
;|*** #define SYSCLR_WINDOWSTATICTEXT 	(-26L)
;|*** #define SYSCLR_SCROLLBAR		(-25L)
;|*** #define SYSCLR_BACKGROUND		(-24L)
;|*** #define SYSCLR_ACTIVETITLE		(-23L)
;|*** #define SYSCLR_INACTIVETITLE		(-22L)
;|*** #define SYSCLR_MENU			(-21L)
;|*** #define SYSCLR_WINDOW			(-20L)
;|*** #define SYSCLR_WINDOWFRAME		(-19L)
;|*** #define SYSCLR_MENUTEXT 		(-18L)
;|*** #define SYSCLR_WINDOWTEXT		(-17L)
;|*** #define SYSCLR_TITLETEXT		(-16L)
;|*** #define SYSCLR_ACTIVEBORDER		(-15L)
;|*** #define SYSCLR_INACTIVEBORDER		(-14L)
;|*** #define SYSCLR_APPWORKSPACE		(-13L)
;|*** #define SYSCLR_HELPBACKGROUND		(-12L)
;|*** #define SYSCLR_HELPTEXT 		(-11L)
;|*** #define SYSCLR_HELPHILITE		(-10L)
;|*** 
;|*** #define SYSCLR_CSYSCOLORS		32L
;|*** 
;|*** #endif /* INCL_WINSYS */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINTIMER) && !defined(INCL_WINTIMER_INCLUDED))
;|*** #define INCL_WINTIMER_INCLUDED
;|*** /**** Timer manager */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** USHORT APIENTRY WinStartTimer(HAB hab, HWND hwnd, USHORT idTimer,
;|*** 			      USHORT dtTimeout);
;|*** BOOL   APIENTRY WinStopTimer(HAB hab, HWND hwnd, USHORT idTimer);
;|*** ULONG  APIENTRY WinGetCurrentTime(HAB hab);
;|*** 
;|*** #define TID_CURSOR	 0xffff  /* Reserved cursor timer ID		  */
;|*** #define TID_SCROLL	 0xfffe  /* Reserved scrolling timer ID 	  */
;|*** #define TID_FLASHWINDOW  0xfffd  /* Reserved for window flashing timer ID */
;|*** #define TID_USERMAX	 0x7fff  /* Maximum user timer ID		  */
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINTIMER */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINACCELERATORS) && !defined(INCL_WINACCELERATORS_INCLUDED))
;|*** #define INCL_WINACCELERATORS_INCLUDED
;|*** /**** Accelerator functions */
;|*** 
;|*** /* ACCEL fs bits
;|***  *
;|***  * NOTE: the first six AF_ code bits have the same value
;|***  * as their KC_ counterparts
;|***  */
;|*** #ifndef INCL_SAADEFS
;|*** #define AF_CHAR 		0x0001
;|*** #define AF_VIRTUALKEY		0x0002
;|*** #define AF_SCANCODE		0x0004
;|*** #define AF_SHIFT		0x0008
;|*** #define AF_CONTROL		0x0010
;|*** #define AF_ALT			0x0020
;|*** #define AF_LONEKEY		0x0040
;|*** #define AF_SYSCOMMAND		0x0100
;|*** #define AF_HELP 		0x0200
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** typedef LHANDLE HACCEL; /* haccel */
;|*** 
;|*** typedef struct _ACCEL { /* acc */
;|*** 	USHORT	fs;
;|*** 	USHORT	key;
;|*** 	USHORT	cmd;
;|*** } ACCEL;
;|*** typedef ACCEL FAR *PACCEL;
;|*** 
;|*** typedef struct _ACCELTABLE { /* acct  */
;|*** 	USHORT	cAccel;
;|*** 	USHORT	codepage;
;|*** 	ACCEL	aaccel[1];
;|*** } ACCELTABLE;
;|*** typedef ACCELTABLE FAR *PACCELTABLE;
;|*** 
;|*** HACCEL APIENTRY WinLoadAccelTable(HAB hab, HMODULE hmod, USHORT idAccelTable);
;|*** HACCEL APIENTRY WinCreateAccelTable(HAB hab, PACCELTABLE pacct);
;|*** BOOL   APIENTRY WinDestroyAccelTable(HACCEL haccel);
;|*** USHORT APIENTRY WinCopyAccelTable(HACCEL haccel, PACCELTABLE pacct,
;|*** 				  USHORT cbCopyMax);
;|*** BOOL   APIENTRY WinTranslateAccel(HAB hab, HWND hwnd, HACCEL haccel,
;|*** 				  PQMSG pqmsg);
;|*** BOOL   APIENTRY WinSetAccelTable(HAB hab, HACCEL haccel, HWND hwndFrame);
;|*** HACCEL APIENTRY WinQueryAccelTable(HAB hab, HWND hwndFrame);
;|*** 
;|*** #endif /* INCL_WINACCELERATORS */
;|*** 
;|*** /**** Extended Attribute Flags (Association Table) */
;|*** 
;|*** #define EAF_DEFAULTOWNER	0x0001
;|*** #define EAF_UNCHANGEABLE	0x0002
;|*** #define EAF_REUSEICON		0x0004
;|*** 
;|*** /*** WinTrackRect() information */
;|*** 
;|*** #if (defined(INCL_WINTRACKRECT) && !defined(INCL_WINTRACKRECT_INCLUDED))
;|*** #define INCL_WINTRACKRECT_INCLUDED
;|*** 
;|*** /* WinTrackRect() tracking information structure */
;|*** 
;|*** typedef struct _TRACKINFO { /* ti */
;|*** 	SHORT	cxBorder;
;|*** 	SHORT	cyBorder;
;|*** 	SHORT	cxGrid;
;|*** 	SHORT	cyGrid;
;|*** 	SHORT	cxKeyboard;
;|*** 	SHORT	cyKeyboard;
;|*** 	RECTL	rclTrack;
;|*** 	RECTL	rclBoundary;
;|*** 	POINTL	ptlMinTrackSize;
;|*** 	POINTL	ptlMaxTrackSize;
;|*** 	USHORT	fs;
;|*** } TRACKINFO;
;|*** typedef TRACKINFO FAR *PTRACKINFO;
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** BOOL APIENTRY WinTrackRect(HWND hwnd, HPS hps, PTRACKINFO pti);
;|*** BOOL APIENTRY WinShowTrackRect(HWND hwnd, BOOL fShow);
;|*** 
;|*** /* WinTrackRect() flags */
;|*** 
;|*** #define TF_LEFT 		0x0001
;|*** #define TF_TOP			0x0002
;|*** #define TF_RIGHT		0x0004
;|*** #define TF_BOTTOM		0x0008
;|*** /* TF_MOVE = TF_LEFT | TF_TOP | TF_RIGHT | TF_BOTTOM */
;|*** #define TF_MOVE 		0x000F
;|*** 
;|*** #define TF_SETPOINTERPOS	0x0010
;|*** #define TF_GRID 		0x0020
;|*** #define TF_STANDARD		0x0040
;|*** #define TF_ALLINBOUNDARY	0x0080
;|*** #define TF_VALIDATETRACKRECT	0x0100
;|*** #define TF_PARTINBOUNDARY	0x0200
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINTRACKRECT */
;|*** 
;|*** 
;|*** /**** Clipboard Manager */
;|*** 
;|*** #if (defined(INCL_WINCLIPBOARD) && !defined(INCL_WINCLIPBOARD_INCLUDED))
;|*** #define INCL_WINCLIPBOARD_INCLUDED
;|*** 
;|*** /* Clipboard messages */
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** #define WM_RENDERFMT		0x0060
;|*** #define WM_RENDERALLFMTS	0x0061
;|*** #define WM_DESTROYCLIPBOARD	0x0062
;|*** #define WM_PAINTCLIPBOARD	0x0063
;|*** #define WM_SIZECLIPBOARD	0x0064
;|*** #define WM_HSCROLLCLIPBOARD	0x0065
;|*** #define WM_VSCROLLCLIPBOARD	0x0066
;|*** #define WM_DRAWCLIPBOARD	0x0067
;|*** 
;|*** /* Standard Clipboard formats */
;|*** 
;|*** #define CF_TEXT 		1
;|*** #define CF_BITMAP		2
;|*** #define CF_DSPTEXT		3
;|*** #define CF_DSPBITMAP		4
;|*** #define CF_METAFILE		5
;|*** #define CF_DSPMETAFILE		6
;|*** 
;|*** BOOL  APIENTRY WinSetClipbrdOwner(HAB hab, HWND hwnd);
;|*** BOOL  APIENTRY WinSetClipbrdData(HAB hab, ULONG ulData, USHORT fmt,
;|*** 				 USHORT fsFmtInfo);
;|*** ULONG APIENTRY WinQueryClipbrdData(HAB hab, USHORT fmt);
;|*** BOOL  APIENTRY WinQueryClipbrdFmtInfo(HAB hab, USHORT fmt,
;|*** 				      PUSHORT pfsFmtInfo);
;|*** BOOL  APIENTRY WinSetClipbrdViewer(HAB hab, HWND hwndNewClipViewer);
;|*** 
;|*** /* WinSetClipbrdData() flags */
;|*** 
;|*** #define CFI_OWNERFREE		0x0001
;|*** #define CFI_OWNERDISPLAY	0x0002
;|*** #define CFI_SELECTOR		0x0100
;|*** #define CFI_HANDLE		0x0200
;|*** 
;|*** #endif /* !INCL_SAADEFS */
;|*** 
;|*** USHORT APIENTRY WinEnumClipbrdFmts(HAB hab, USHORT fmt);
;|*** BOOL   APIENTRY WinEmptyClipbrd(HAB hab);
;|*** BOOL   APIENTRY WinOpenClipbrd(HAB hab);
;|*** BOOL   APIENTRY WinCloseClipbrd(HAB hab);
;|*** HWND   APIENTRY WinQueryClipbrdOwner(HAB hab, BOOL fLock);
;|*** HWND   APIENTRY WinQueryClipbrdViewer(HAB hab, BOOL fLock);
;|*** 
;|*** #endif /* INCL_WINCLIPBOARD */
;|*** 
;|*** 
;|*** #if (defined(INCL_WINCURSORS) || !defined(INCL_NOCOMMON))
;|*** /**** Cursor manager common subsection */
;|*** 
;|*** BOOL APIENTRY WinDestroyCursor(HWND hwnd);
;|*** BOOL APIENTRY WinShowCursor(HWND hwnd, BOOL fShow);
;|*** BOOL APIENTRY WinCreateCursor(HWND hwnd, SHORT x, SHORT y, SHORT cx,
;|*** 			      SHORT cy, USHORT fs, PRECTL prclClip);
;|*** 
;|*** /* WinCreateCursor() flags */
;|*** 
;|*** #define CURSOR_SOLID		0x0000
;|*** #define CURSOR_HALFTONE 	0x0001
;|*** #define CURSOR_FRAME		0x0002
;|*** #define CURSOR_FLASH		0x0004
;|*** #define CURSOR_SETPOS		0x8000
;|*** 
;|*** 
;|*** #endif /* Cursor manager common subsection */
;|*** 
;|*** #if (defined(INCL_WINCURSORS) && !defined(INCL_WINCURSORS_INCLUDED))
;|*** #define INCL_WINCURSORS_INCLUDED
;|*** 
;|*** typedef struct _CURSORINFO { /* csri */
;|*** 	HWND	hwnd;
;|*** 	SHORT	x;
;|*** 	SHORT	y;
;|*** 	SHORT	cx;
;|*** 	SHORT	cy;
;|*** 	USHORT	fs;
;|*** 	RECTL	rclClip;
;|*** } CURSORINFO;
;|*** typedef CURSORINFO FAR *PCURSORINFO;
;|*** 
;|*** BOOL APIENTRY WinQueryCursorInfo(HWND hwndDesktop, PCURSORINFO pcsri);
;|*** 
;|*** #endif /* INCL_WINCURSORS */
;|*** 
;|*** typedef LHANDLE HPOINTER;   /* hptr */
;|*** 
;|*** #if (defined(INCL_WINPOINTERS) && !defined(INCL_WINPOINTERS_INCLUDED))
;|*** #define INCL_WINPOINTERS_INCLUDED
;|*** /**** Pointer manager */
;|*** 
;|*** BOOL     APIENTRY WinSetPointer(HWND hwndDesktop, HPOINTER hptrNew);
;|*** BOOL     APIENTRY WinShowPointer(HWND hwndDesktop, BOOL fShow);
;|*** HPOINTER APIENTRY WinQuerySysPointer(HWND hwndDesktop, SHORT iptr, BOOL fLoad);
;|*** 
;|*** 
;|*** /* System pointers (NOTE: these are 1-based) */
;|*** 
;|*** #ifdef LATER
;|*** 
;|*** #define SPTR_ARROW		1
;|*** #define SPTR_TEXT		2
;|*** #define SPTR_WAIT		3
;|*** #define SPTR_MOVE		4
;|*** #define SPTR_SIZENWSE		5
;|*** #define SPTR_SIZENESW		6
;|*** #define SPTR_SIZEWE		7
;|*** #define SPTR_SIZENS		8
;|*** #define SPTR_APPICON		9
;|*** 
;|*** #define SPTR_ICONINFORMATION	10
;|*** #define SPTR_ICONQUESTION	11
;|*** #define SPTR_ICONERROR		12
;|*** #define SPTR_ICONWARNING	13
;|*** 
;|*** #define SPTR_CPTR		13    /* Count of pointers loaded by PMWIN */
;|*** 
;|*** #define SPTR_ILLEGAL		14
;|*** #define SPTR_FILE		15
;|*** #define SPTR_FOLDER		16
;|*** #define SPTR_MULTFILE		17
;|*** #define SPTR_PROGRAM		18
;|*** 
;|*** #else
;|*** 
;|*** #define SPTR_ARROW		1
;|*** #define SPTR_TEXT		2
;|*** #define SPTR_WAIT		3
;|*** #define SPTR_SIZE		4
;|*** #define SPTR_MOVE		5
;|*** #define SPTR_SIZENWSE		6
;|*** #define SPTR_SIZENESW		7
;|*** #define SPTR_SIZEWE		8
;|*** #define SPTR_SIZENS		9
;|*** #define SPTR_APPICON		10
;|*** #define SPTR_ICONINFORMATION	11
;|*** #define SPTR_ICONQUESTION	12
;|*** #define SPTR_ICONERROR		13
;|*** #define SPTR_ICONWARNING	14
;|*** #define SPTR_CPTR		14	/* count loaded by pmwin */
;|*** 
;|*** #define SPTR_ILLEGAL		18
;|*** #define SPTR_FILE		19
;|*** #define SPTR_FOLDER		20
;|*** #define SPTR_MULTFILE		21
;|*** #define SPTR_PROGRAM		22
;|*** 
;|*** /* backward compatibility */
;|*** #define SPTR_HANDICON		SPTR_ICONERROR
;|*** #define SPTR_QUESICON		SPTR_ICONQUESTION
;|*** #define SPTR_BANGICON		SPTR_ICONWARNING
;|*** #define SPTR_NOTEICON		SPTR_ICONINFORMATION
;|*** 
;|*** #endif /* LATER */
;|*** 
;|*** HPOINTER APIENTRY WinLoadPointer(HWND hwndDesktop, HMODULE hmod,
;|*** 				 USHORT idPtr);
;|*** BOOL	 APIENTRY WinDestroyPointer(HPOINTER hptr);
;|*** HPOINTER APIENTRY WinCreatePointer(HWND hwndDesktop, HBITMAP hbmPointer,
;|*** 				   BOOL fPointer, SHORT xHotspot,
;|*** 				   SHORT yHotspot);
;|*** 
;|*** HPOINTER APIENTRY WinQueryPointer(HWND hwndDesktop);
;|*** BOOL     APIENTRY WinSetPointerPos(HWND hwndDesktop, SHORT x, SHORT y);
;|*** BOOL     APIENTRY WinQueryPointerPos(HWND hwndDesktop, PPOINTL pptl);
;|*** 
;|*** typedef struct _POINTERINFO { /* ptri */
;|*** 	BOOL	fPointer;
;|*** 	SHORT	xHotspot;
;|*** 	SHORT	yHotspot;
;|*** 	HBITMAP hbmPointer;
;|*** 	HBITMAP hbmColor;
;|*** } POINTERINFO;
;|*** typedef POINTERINFO FAR *PPOINTERINFO;
;|*** 
;|*** HPOINTER APIENTRY WinCreatePointerIndirect(HWND hwndDesktop,
;|*** 					   PPOINTERINFO pptri);
;|*** BOOL	 APIENTRY WinQueryPointerInfo(HPOINTER hptr,
;|*** 				      PPOINTERINFO pptri);
;|*** BOOL	 APIENTRY WinDrawPointer(HPS hps, SHORT x, SHORT y, HPOINTER hptr,
;|*** 				 USHORT fs);
;|*** 
;|*** 
;|*** 
;|*** /* WinDrawPointer() constants */
;|*** 
;|*** #define DP_NORMAL		0x0000
;|*** #define DP_HALFTONED		0x0001
;|*** #define DP_INVERTED		0x0002
;|*** 
;|*** 
;|*** HBITMAP APIENTRY WinGetSysBitmap(HWND hwndDesktop, USHORT ibm);
;|*** 
;|*** /* System bitmaps (NOTE: these are 1-based) */
;|*** 
;|*** #define SBMP_OLD_SYSMENU	1
;|*** #define SBMP_OLD_SBUPARROW	2
;|*** #define SBMP_OLD_SBDNARROW	3
;|*** #define SBMP_OLD_SBRGARROW	4
;|*** #define SBMP_OLD_SBLFARROW	5
;|*** #define SBMP_MENUCHECK		6
;|*** #define SBMP_CHECKBOXES 	7
;|*** #define SBMP_BTNCORNERS 	8
;|*** #define SBMP_OLD_MINBUTTON	9
;|*** #define SBMP_OLD_MAXBUTTON	10
;|*** #define SBMP_OLD_RESTOREBUTTON	11
;|*** #define SBMP_OLD_CHILDSYSMENU	12
;|*** #define SBMP_DRIVE		15
;|*** #define SBMP_FILE		16
;|*** #define SBMP_FOLDER		17
;|*** #define SBMP_TREEPLUS		18
;|*** #define SBMP_TREEMINUS		19
;|*** #define SBMP_PROGRAM		22
;|*** #define SBMP_MENUATTACHED	23
;|*** #define SBMP_SIZEBOX		24
;|*** 
;|*** #define SBMP_SYSMENU		25
;|*** #define SBMP_MINBUTTON		26
;|*** #define SBMP_MAXBUTTON		27
;|*** #define SBMP_RESTOREBUTTON	28
;|*** #define SBMP_CHILDSYSMENU	29
;|*** #define SBMP_SYSMENUDEP 	30
;|*** #define SBMP_MINBUTTONDEP	31
;|*** #define SBMP_MAXBUTTONDEP	32
;|*** #define SBMP_RESTOREBUTTONDEP	33
;|*** #define SBMP_CHILDSYSMENUDEP	34
;|*** #define SBMP_SBUPARROW		35
;|*** #define SBMP_SBDNARROW		36
;|*** #define SBMP_SBLFARROW		37
;|*** #define SBMP_SBRGARROW		38
;|*** #define SBMP_SBUPARROWDEP	39
;|*** #define SBMP_SBDNARROWDEP	40
;|*** #define SBMP_SBLFARROWDEP	41
;|*** #define SBMP_SBRGARROWDEP	42
;|*** #define SBMP_SBUPARROWDIS	43
;|*** #define SBMP_SBDNARROWDIS	44
;|*** #define SBMP_SBLFARROWDIS	45
;|*** #define SBMP_SBRGARROWDIS	46
;|*** #define SBMP_COMBODOWN		47
;|*** 
;|*** #endif /* INCL_WINPOINTERS */
;|*** 
;|*** 
;|*** /**** Hook manager */
;|*** 
;|*** #if (defined(INCL_WINHOOKS) && !defined(INCL_WINHOOKS_INCLUDED))
;|*** #define INCL_WINHOOKS_INCLUDED
;|*** 
;|*** #ifndef INCL_SAADEFS
;|*** BOOL APIENTRY WinSetHook(HAB hab, HMQ hmq, SHORT iHook, PFN pfnHook,
;|*** 			 HMODULE hmod);
;|*** BOOL APIENTRY WinReleaseHook(HAB hab, HMQ hmq, SHORT iHook, PFN pfnHook,
;|*** 			     HMODULE hmod);
;|*** BOOL APIENTRY WinCallMsgFilter(HAB hab, PQMSG pqmsg, USHORT msgf);
;|*** 
;|*** 
;|*** /* Hook codes */
;|*** 
;|*** #define HK_SENDMSG		   0
;|***     /* VOID EXPENTRY SendMsgHook(HAB hab,		** installer's hab      **
;|*** 				 PSMHSTRUCT psmh,	** p send msg struct	**
;|*** 				 BOOL fInterTask);	** between threads	*/
;|*** #define HK_INPUT		   1
;|***     /* BOOL EXPENTRY InputHook(HAB hab, 		** installer's hab      **
;|*** 			       PQMSG pQmsg,		** p qmsg		**
;|*** 			       USHORT fs);		** remove/noremove	*/
;|*** #define HK_MSGFILTER		   2
;|***     /* BOOL EXPENTRY MsgFilterHook(HAB hab,		** installer's hab      **
;|*** 				   PQMSG pQmsg, 	** p qmsg		**
;|*** 				   USHORT msgf);	** filter flag		*/
;|*** #define HK_JOURNALRECORD	   3
;|***     /* VOID EXPENTRY JournalRecordHook(HAB hab, 	** installer's hab      **
;|***                                        PQMSG pQmsg);    ** p qmsg               */
;|*** #define HK_JOURNALPLAYBACK	   4
;|***     /* ULONG EXPENTRY JournalPlaybackHook(HAB hab,	**installer's hab       **
;|*** 					  BOOL fSkip,	** skip messages	**
;|*** 					  PQMSG pQmsg); ** p qmsg		*/
;|*** #define HK_HELP 		   5
;|***     /* BOOL EXPENTRY HelpHook(HAB hab,			** installer's hab      **
;|*** 			      USHORT usMode,		** mode 		**
;|*** 			      USHORT idTopic,		** main topic		**
;|*** 			      USHORT idSubTopic,	** sub topic		**
;|*** 			      PRECTL prcPosition);	** associated position	*/
;|*** 
;|*** #define HK_LOADER		   6
;|***     /* BOOL EXPENTRY LoaderHook(HAB hab,		** installer's hab      **
;|*** 				SHORT idContext,	** who called hook	**
;|*** 				PSZ pszLibname, 	** lib name string	**
;|*** 				PHLIB hlib,		** p to lib handle	**
;|*** 				PSZ pszProcname,	** procedure name	**
;|*** 				PFNWP wndProc); 	** window procedure	*/
;|*** #define HK_REGISTERUSERMSG	   7
;|***     /* BOOL EXPENTRY RegisterUserHook(HAB hab,		** installer's hab      **
;|*** 				    ULONG cUshort,	** entries in arRMP	**
;|*** 				    PUSHORT arRMP,	** RMP array		**
;|*** 				    PBOOL fRegistered); ** msg parms already reg*/
;|*** #define HK_MSGCONTROL		   8
;|***     /* BOOL EXPENTRY MsgControlHook(HAB hab,		** installer's hab      **
;|*** 				    SHORT idContext,	** who called hook	**
;|*** 				    HWND hwnd,		** SEI window handle	**
;|*** 				    PSZ pszClassname,	** window class name	**
;|*** 				    USHORT usMsgclass,	** interested msg class **
;|*** 				    SHORT idControl,	** SMI_*		**
;|*** 				    PBOOL fSuccess);	** mode already set	*/
;|*** #define HK_PLIST_ENTRY		   9
;|***     /* BOOL EXPENTRY ProgramListEntryHook(HAB hab,	** installer's hab      **
;|*** 		       PPRFHOOKPARMS pProfileHookParams,** data 		**
;|*** 		       PBOOL fNoExecute);		** cease hook processing*/
;|*** #define HK_PLIST_EXIT		   10
;|***     /* BOOL EXPENTRY ProgramListExitHook(HAB hab,	** installer's hab      **
;|*** 		PPRFHOOKPARMS pProfileHookParams);	** data 		*/
;|*** #define HK_FINDWORD		   11
;|***     /* BOOL EXPENTRY FindWordHook(usCodepage,		** code page to use	**
;|*** 				  PSZ pszText,		** text to break	**
;|*** 				  ULONG cb,		** maximum text size	**
;|*** 				  ULONG ich,		** break 'near' here	**
;|*** 				  PULONG pichStart,	** where break began	**
;|*** 				  PULONG pichEnd,	** where break ended	**
;|*** 				  PULONG pichNext);	** where next word begin*/
;|*** #define HK_CODEPAGECHANGED	   12
;|***     /* VOID EXPENTRY CodePageChangedHook(HMQ hmq,	** msg q handle 	**
;|*** 				  USHORT usOldCodepage, ** old code page	**
;|*** 				  USHORT usNewCodepage);** new code page	*/
;|*** 
;|*** #define HMQ_CURRENT		((HMQ)1)
;|*** 
;|*** /* WH_MSGFILTER context codes */
;|*** 
;|*** #define MSGF_DIALOGBOX		1
;|*** #define MSGF_MESSAGEBOX 	2
;|*** #define MSGF_TRACK		8
;|*** 
;|*** /* HK_HELP Help modes */
;|*** 
;|*** #define HLPM_FRAME		(-1)
;|*** #define HLPM_WINDOW		(-2)
;|*** #define HLPM_MENU		(-3)
;|*** 
;|*** /* HK_SENDMSG structure */
;|*** 
;|*** typedef struct _SMHSTRUCT { /* smhs */
;|*** 	MPARAM	mp2;
;|*** 	MPARAM	mp1;
;|*** 	USHORT	msg;
;|*** 	HWND	hwnd;
;|*** } SMHSTRUCT;
;|*** typedef SMHSTRUCT FAR *PSMHSTRUCT;
;|*** 
;|*** /*HK_LOADER context codes */
;|*** 
;|*** #define LHK_DELETEPROC		1
;|*** #define LHK_DELETELIB		2
;|*** #define LHK_LOADPROC		3
;|*** #define LHK_LOADLIB		4
;|*** 
;|*** /*HK_MSGCONTROL context codes */
;|*** 
;|*** #define MCHK_MSGINTEREST	1
;|*** #define MCHK_CLASSMSGINTEREST	2
;|*** #define MCHK_SYNCHRONISATION	3
;|*** #define MCHK_MSGMODE		4
;|*** 
;|*** /*HK_REGISTERUSERMSG conext codes */
;|*** 
;|*** #define RUMHK_DATATYPE		1
;|*** #define RUMHK_MSG		2
;|*** 
;|*** #endif /* INCL_SAADEFS */
;|*** 
;|*** #endif /* INCL_WINHOOKS */
;|*** 
;|*** /*
;|***  * Include Shell API
;|***  */
;|*** #ifndef INCL_SAADEFS
;|*** #include <pmshl.h>      /* OS/2 Shell definitions */
; Line 2727
;|*** #include <pmgpi.h>	/* OS/2 GPI definitions 	      */
; Line 41
;|*** #include <pmdev.h>	/* OS/2 Device Context definitions    */
; Line 42
;|*** #include "genscsi.h"
; Line 160
;|*** #include "const.h"
; Line 1
;|*** #include "struc.h"
; Line 2
;|*** #include "externs.h"
; Line 3
;|*** 
;|*** idc_type near scsi_idc;
;|*** void far * near idc_entry;
;|*** byte near scsi_name[] = "SCSI-02$";
;|*** HFILE near  handle;
;|*** word  near  gdt_selector[4];
;|*** 
;|*** word far transfer_scb(reqhdr_type *);
;|*** 
;|*** word far scsi_init(void)
;|*** {
; Line 171
	PUBLIC	_scsi_init
_scsi_init	PROC FAR
	*** 000000	55 			push	bp
	*** 000001	8b ec 			mov	bp,sp
	*** 000003	81 ec 38 00 		sub	sp,56
	*** 000007	57 			push	di
	*** 000008	56 			push	si
;	temp = -8
;	in_regs = -30
;	out_regs = -52
;	oflag = -54
;	omode = -2
;	action = -56
;	rc = -4
;|***   _32bits temp;
;|***   union cpu_regs in_regs;
;|***   union cpu_regs out_regs;
;|***   word        oflag;
;|***   word        omode;
;|***   USHORT      action;
;|***   word        rc;
;|*** 
;|***   /* Get 4 GDT selectors */
;|***   temp.fptr = (void far *)gdt_selector;
; Line 181
	*** 000009	c7 46 f8 00 00 		mov	WORD PTR [bp-8],OFFSET DGROUP:_gdt_selector	;temp
	*** 00000e	8c 5e fa 		mov	WORD PTR [bp-6],ds
;|***   if (get_gdt_slots(4,temp)) { return(ERROR+DONE+GEN_FAIL); }
; Line 182
	*** 000011	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000014	ff 76 f8 		push	WORD PTR [bp-8]	;temp
	*** 000017	b8 04 00 		mov	ax,4
	*** 00001a	50 			push	ax
	*** 00001b	9a 00 00 00 00 		call	FAR PTR _get_gdt_slots
	*** 000020	83 c4 06 		add	sp,6
	*** 000023	3d 00 00 		cmp	ax,0
	*** 000026	75 03 			jne	$JCC38
	*** 000028	e9 06 00 		jmp	$I1269
					$JCC38:
	*** 00002b	b8 0c 81 		mov	ax,-32500
	*** 00002e	e9 aa 00 		jmp	$EX1261
;|*** 
;|***   /* Do the Attach_DD call */
;|***   temp.fptr = (void far *)scsi_name;
; Line 185
					$I1269:
	*** 000031	c7 46 f8 00 00 		mov	WORD PTR [bp-8],OFFSET DGROUP:_scsi_name	;temp
	*** 000036	8c 5e fa 		mov	WORD PTR [bp-6],ds
;|***   in_regs.W.BX = temp._segadr.offset;
; Line 186
	*** 000039	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;temp
	*** 00003c	89 46 e4 		mov	WORD PTR [bp-28],ax
;|***   temp.fptr = (void far *)&scsi_idc;
; Line 187
	*** 00003f	c7 46 f8 00 00 		mov	WORD PTR [bp-8],OFFSET DGROUP:_scsi_idc	;temp
	*** 000044	8c 5e fa 		mov	WORD PTR [bp-6],ds
;|***   in_regs.W.DI = temp._segadr.offset;
; Line 188
	*** 000047	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;temp
	*** 00004a	89 46 ec 		mov	WORD PTR [bp-20],ax
;|***   in_regs.W.es_valid = FALSE;
; Line 189
	*** 00004d	c6 46 f6 00 		mov	BYTE PTR [bp-10],0
;|***   in_regs.W.ds_valid = FALSE;
; Line 190
	*** 000051	c6 46 f7 00 		mov	BYTE PTR [bp-9],0
;|***   in_regs.B.DL = devhlp_AttachDD;
; Line 191
	*** 000055	c6 46 e8 2a 		mov	BYTE PTR [bp-24],42
;|***   dev_help(&in_regs,&out_regs);
; Line 192
	*** 000059	8d 46 cc 		lea	ax,WORD PTR [bp-52]	;out_regs
	*** 00005c	16 			push	ss
	*** 00005d	50 			push	ax
	*** 00005e	8d 46 e2 		lea	ax,WORD PTR [bp-30]	;in_regs
	*** 000061	16 			push	ss
	*** 000062	50 			push	ax
	*** 000063	9a 00 00 00 00 		call	FAR PTR _dev_help
	*** 000068	83 c4 08 		add	sp,8
;|***   if ((out_regs.W.flags & 0x0001) != 0) { return(ERROR+DONE+GEN_FAIL); }
; Line 193
	*** 00006b	f6 46 de 01 		test	BYTE PTR [bp-34],1
	*** 00006f	75 03 			jne	$JCC111
	*** 000071	e9 06 00 		jmp	$I1270
					$JCC111:
	*** 000074	b8 0c 81 		mov	ax,-32500
	*** 000077	e9 61 00 		jmp	$EX1261
;|*** 
;|***   /* Save the entry point values */
;|***   temp._segadr.segment = scsi_idc.prot_CS;
; Line 196
					$I1270:
	*** 00007a	a1 08 00 		mov	ax,WORD PTR _scsi_idc+8
	*** 00007d	89 46 fa 		mov	WORD PTR [bp-6],ax
;|***   temp._segadr.offset  = scsi_idc.prot_IP;
; Line 197
	*** 000080	a1 06 00 		mov	ax,WORD PTR _scsi_idc+6
	*** 000083	89 46 f8 		mov	WORD PTR [bp-8],ax	;temp
;|***   idc_entry = temp.fptr;
; Line 198
	*** 000086	8b 46 f8 		mov	ax,WORD PTR [bp-8]	;temp
	*** 000089	8b 56 fa 		mov	dx,WORD PTR [bp-6]
	*** 00008c	a3 00 00 		mov	WORD PTR _idc_entry,ax
	*** 00008f	89 16 02 00 		mov	WORD PTR _idc_entry+2,dx
;|*** 
;|***   /* Get a handle to the SCSI DD */
;|***   omode = 0x0012;
; Line 201
	*** 000093	c7 46 fe 12 00 		mov	WORD PTR [bp-2],18	;omode
;|***   oflag = 0x0001;
; Line 202
	*** 000098	c7 46 ca 01 00 		mov	WORD PTR [bp-54],1	;oflag
;|***   rc = DosOpen(scsi_name,                   /* File name */
;|***                &handle,                     /* Handle    */
;|***                &action,                     /* Action taken */
;|***                0L,                          /* File len */
;|***                0,                           /* Attribute - normal file */
;|***                oflag,                       /* Open flag */
;|***                omode,                       /* Open mode */
;|***                0L);
; Line 210
	*** 00009d	b8 00 00 		mov	ax,OFFSET DGROUP:_scsi_name
	*** 0000a0	1e 			push	ds
	*** 0000a1	50 			push	ax
	*** 0000a2	b8 00 00 		mov	ax,OFFSET DGROUP:_handle
	*** 0000a5	1e 			push	ds
	*** 0000a6	50 			push	ax
	*** 0000a7	8d 46 c8 		lea	ax,WORD PTR [bp-56]	;action
	*** 0000aa	16 			push	ss
	*** 0000ab	50 			push	ax
	*** 0000ac	2b c0 			sub	ax,ax
	*** 0000ae	50 			push	ax
	*** 0000af	50 			push	ax
	*** 0000b0	b8 00 00 		mov	ax,0
	*** 0000b3	50 			push	ax
	*** 0000b4	ff 76 ca 		push	WORD PTR [bp-54]	;oflag
	*** 0000b7	ff 76 fe 		push	WORD PTR [bp-2]	;omode
	*** 0000ba	2b c9 			sub	cx,cx
	*** 0000bc	51 			push	cx
	*** 0000bd	51 			push	cx
	*** 0000be	9a 00 00 00 00 		call	FAR PTR DOSOPEN
	*** 0000c3	89 46 fc 		mov	WORD PTR [bp-4],ax	;rc
;|*** 
;|***   /* If it failed, return to the caller */
;|***   if (rc) { return(ERROR+DONE+GEN_FAIL); }
; Line 213
	*** 0000c6	83 7e fc 00 		cmp	WORD PTR [bp-4],0	;rc
	*** 0000ca	75 03 			jne	$JCC202
	*** 0000cc	e9 06 00 		jmp	$I1271
					$JCC202:
	*** 0000cf	b8 0c 81 		mov	ax,-32500
	*** 0000d2	e9 06 00 		jmp	$EX1261
;|*** 
;|***   return(0);
; Line 215
					$I1271:
	*** 0000d5	b8 00 00 		mov	ax,0
	*** 0000d8	e9 00 00 		jmp	$EX1261
;|*** 
;|*** }
; Line 217
					$EX1261:
	*** 0000db	5e 			pop	si
	*** 0000dc	5f 			pop	di
	*** 0000dd	8b e5 			mov	sp,bp
	*** 0000df	5d 			pop	bp
	*** 0000e0	cb 			ret	

_scsi_init	ENDP
;|*** 
;|*** word far call_scsi(reqhdr_type *in_req)
;|*** {
; Line 220
	PUBLIC	_call_scsi
_call_scsi	PROC FAR
	*** 0000e1	55 			push	bp
	*** 0000e2	8b ec 			mov	bp,sp
	*** 0000e4	81 ec 20 00 		sub	sp,32
	*** 0000e8	57 			push	di
	*** 0000e9	56 			push	si
;	xfer_phys = -20
;	dhandle = -4
;	newreq = -12
;	req = -28
;	temp = -16
;	p_lock = -24
;	d_lock = -32
;	sense_phys = -8
;	in_req = 6
;|***    ioctl_hdr2    *newreq;
;|***    ioctl_hdr2    *req;
;|***    _32bits        temp;
;|***    unsigned long  p_lock;
;|***    unsigned long  d_lock;
;|***    _32bits        sense_phys;
;|***    _32bits        xfer_phys;
;|***    word          *dhandle;
;|*** 
;|***    /* Cast the request header */
;|***    req = (ioctl_hdr2 *)in_req;
; Line 231
	*** 0000ea	8b 46 06 		mov	ax,WORD PTR [bp+6]	;in_req
	*** 0000ed	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 0000f0	89 46 e4 		mov	WORD PTR [bp-28],ax	;req
	*** 0000f3	89 56 e6 		mov	WORD PTR [bp-26],dx
;|*** 
;|***    /* Make sure it is one of ours */
;|***    if (req->funct_cat != 0x80) {
; Line 234
	*** 0000f6	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0000f9	26 80 7f 0d 80 		cmp	BYTE PTR es:[bx+13],128
	*** 0000fe	75 03 			jne	$JCC254
	*** 000100	e9 0f 00 		jmp	$I1282
					$JCC254:
;|***        in_req->rh_stat = ERROR+INV_CMD;
; Line 235
	*** 000103	c4 5e 06 		les	bx,DWORD PTR [bp+6]	;in_req
	*** 000106	26 c7 47 03 03 80 	mov	WORD PTR es:[bx+3],-32765
;|*** 
;|***        /* Devdone the packet  */
;|***        return(ERROR+INV_CMD);
; Line 238
	*** 00010c	b8 03 80 		mov	ax,-32765
	*** 00010f	e9 e8 02 		jmp	$EX1273
;|***        }
; Line 239
;|*** 
;|***    /* Handle Transfer SCB separately */
;|***    if ((req->funct_cat == 0x80) && (req->funct_cod == 0x52)) {
; Line 242
					$I1282:
	*** 000112	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000115	26 80 7f 0d 80 		cmp	BYTE PTR es:[bx+13],128
	*** 00011a	74 03 			je	$JCC282
	*** 00011c	e9 1e 00 		jmp	$I1283
					$JCC282:
	*** 00011f	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000122	26 80 7f 0e 52 		cmp	BYTE PTR es:[bx+14],82
	*** 000127	74 03 			je	$JCC295
	*** 000129	e9 11 00 		jmp	$I1283
					$JCC295:
;|***        return(transfer_scb(in_req));
; Line 243
	*** 00012c	ff 76 08 		push	WORD PTR [bp+8]
	*** 00012f	ff 76 06 		push	WORD PTR [bp+6]	;in_req
	*** 000132	9a 00 00 00 00 		call	FAR PTR _transfer_scb
	*** 000137	83 c4 04 		add	sp,4
	*** 00013a	e9 bd 02 		jmp	$EX1273
;|***        }
; Line 244
;|*** 
;|***    /* If it is an ALLOCATE request */
;|***    if ((req->funct_cat == 0x80) && (req->funct_cod == 0x55)) {
; Line 247
					$I1283:
	*** 00013d	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000140	26 80 7f 0d 80 		cmp	BYTE PTR es:[bx+13],128
	*** 000145	74 03 			je	$JCC325
	*** 000147	e9 37 00 		jmp	$I1284
					$JCC325:
	*** 00014a	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 00014d	26 80 7f 0e 55 		cmp	BYTE PTR es:[bx+14],85
	*** 000152	74 03 			je	$JCC338
	*** 000154	e9 2a 00 		jmp	$I1284
					$JCC338:
;|*** 
;|***       /* Check to see that we haven't maxed out the allocs for this handle */
;|***       if (0 == get_avail_devh(req->file_number)) {
; Line 250
	*** 000157	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 00015a	26 ff 77 17 		push	WORD PTR es:[bx+23]
	*** 00015e	9a 00 00 00 00 		call	FAR PTR _get_avail_devh
	*** 000163	83 c4 02 		add	sp,2
	*** 000166	3d 00 00 		cmp	ax,0
	*** 000169	74 03 			je	$JCC361
	*** 00016b	e9 13 00 		jmp	$I1285
					$JCC361:
;|*** 
;|***          /* If we did max them out, return an error */
;|***          req->request_hdr.rh_stat   = ERROR+DONE+0x90;
; Line 253
	*** 00016e	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000171	26 c7 47 03 90 81 	mov	WORD PTR es:[bx+3],-32368
;|***          return(req->request_hdr.rh_stat);
; Line 254
	*** 000177	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 00017a	26 8b 47 03 		mov	ax,WORD PTR es:[bx+3]
	*** 00017e	e9 79 02 		jmp	$EX1273
;|***          }
; Line 255
;|***       }
; Line 256
					$I1285:
;|*** 
;|***    /* Make a request packet */
;|***    temp = alloc_req();
; Line 259
					$I1284:
	*** 000181	9a 00 00 00 00 		call	FAR PTR _alloc_req
	*** 000186	89 46 f0 		mov	WORD PTR [bp-16],ax	;temp
	*** 000189	89 56 f2 		mov	WORD PTR [bp-14],dx
;|*** 
;|***    /* if it worked, cast the pointer */
;|***    if (temp.phys)  { newreq = (ioctl_hdr2 *)temp.fptr; }
; Line 262
	*** 00018c	8b 46 f2 		mov	ax,WORD PTR [bp-14]
	*** 00018f	0b 46 f0 		or	ax,WORD PTR [bp-16]	;temp
	*** 000192	75 03 			jne	$JCC402
	*** 000194	e9 0f 00 		jmp	$I1286
					$JCC402:
	*** 000197	8b 46 f0 		mov	ax,WORD PTR [bp-16]	;temp
	*** 00019a	8b 56 f2 		mov	dx,WORD PTR [bp-14]
	*** 00019d	89 46 f4 		mov	WORD PTR [bp-12],ax	;newreq
	*** 0001a0	89 56 f6 		mov	WORD PTR [bp-10],dx
;|*** 
;|***    /* if it failed, exit with an error */
;|***    else { return(ERROR+DONE+GEN_FAIL); }
; Line 265
	*** 0001a3	e9 06 00 		jmp	$I1287
					$I1286:
	*** 0001a6	b8 0c 81 		mov	ax,-32500
	*** 0001a9	e9 4e 02 		jmp	$EX1273
					$I1287:
;|*** 
;|***    /* Copy the common parms from the first to the new one */
;|***    newreq->request_hdr.rh_len    = req->request_hdr.rh_len;
; Line 268
	*** 0001ac	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0001af	26 8a 07 		mov	al,BYTE PTR es:[bx]
	*** 0001b2	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 0001b5	26 88 07 		mov	BYTE PTR es:[bx],al
;|***    newreq->request_hdr.rh_unit   = req->request_hdr.rh_unit;
; Line 269
	*** 0001b8	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0001bb	26 8a 47 01 		mov	al,BYTE PTR es:[bx+1]
	*** 0001bf	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 0001c2	26 88 47 01 		mov	BYTE PTR es:[bx+1],al
;|***    newreq->request_hdr.rh_cmd    = req->request_hdr.rh_cmd;
; Line 270
	*** 0001c6	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0001c9	26 8a 47 02 		mov	al,BYTE PTR es:[bx+2]
	*** 0001cd	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 0001d0	26 88 47 02 		mov	BYTE PTR es:[bx+2],al
;|***    newreq->request_hdr.rh_stat   = req->request_hdr.rh_stat;
; Line 271
	*** 0001d4	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0001d7	26 8b 47 03 		mov	ax,WORD PTR es:[bx+3]
	*** 0001db	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 0001de	26 89 47 03 		mov	WORD PTR es:[bx+3],ax
;|***    newreq->request_hdr.rh_resrvd = req->request_hdr.rh_resrvd;
; Line 272
	*** 0001e2	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0001e5	26 8b 47 05 		mov	ax,WORD PTR es:[bx+5]
	*** 0001e9	26 8b 57 07 		mov	dx,WORD PTR es:[bx+7]
	*** 0001ed	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 0001f0	26 89 47 05 		mov	WORD PTR es:[bx+5],ax
	*** 0001f4	26 89 57 07 		mov	WORD PTR es:[bx+7],dx
;|***    newreq->request_hdr.rh_next   = req->request_hdr.rh_next;
; Line 273
	*** 0001f8	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0001fb	26 8b 47 09 		mov	ax,WORD PTR es:[bx+9]
	*** 0001ff	26 8b 57 0b 		mov	dx,WORD PTR es:[bx+11]
	*** 000203	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 000206	26 89 47 09 		mov	WORD PTR es:[bx+9],ax
	*** 00020a	26 89 57 0b 		mov	WORD PTR es:[bx+11],dx
;|***    newreq->funct_cat             = req->funct_cat;
; Line 274
	*** 00020e	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000211	26 8a 47 0d 		mov	al,BYTE PTR es:[bx+13]
	*** 000215	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 000218	26 88 47 0d 		mov	BYTE PTR es:[bx+13],al
;|***    newreq->funct_cod             = req->funct_cod;
; Line 275
	*** 00021c	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 00021f	26 8a 47 0e 		mov	al,BYTE PTR es:[bx+14]
	*** 000223	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 000226	26 88 47 0e 		mov	BYTE PTR es:[bx+14],al
;|***    newreq->pbuf_len              = req->pbuf_len;
; Line 276
	*** 00022a	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 00022d	26 8b 47 19 		mov	ax,WORD PTR es:[bx+25]
	*** 000231	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 000234	26 89 47 19 		mov	WORD PTR es:[bx+25],ax
;|***    newreq->dbuf_len              = req->dbuf_len;
; Line 277
	*** 000238	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 00023b	26 8b 47 1b 		mov	ax,WORD PTR es:[bx+27]
	*** 00023f	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 000242	26 89 47 1b 		mov	WORD PTR es:[bx+27],ax
;|*** 
;|***    /* Convert the Parm buffer pointer to a GDT based address and store in */
;|***    /* the new request packet, after locking it */
;|***    p_lock = lock(newreq->pbuffer._segadr.segment);
; Line 281
	*** 000246	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 000249	26 ff 77 11 		push	WORD PTR es:[bx+17]
	*** 00024d	9a 00 00 00 00 		call	FAR PTR _lock
	*** 000252	83 c4 02 		add	sp,2
	*** 000255	89 46 e8 		mov	WORD PTR [bp-24],ax	;p_lock
	*** 000258	89 56 ea 		mov	WORD PTR [bp-22],dx
;|***    xfer_phys       = get_phys_addr(req->pbuffer);
; Line 282
	*** 00025b	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 00025e	26 ff 77 11 		push	WORD PTR es:[bx+17]
	*** 000262	26 ff 77 0f 		push	WORD PTR es:[bx+15]
	*** 000266	9a 00 00 00 00 		call	FAR PTR _get_phys_addr
	*** 00026b	83 c4 04 		add	sp,4
	*** 00026e	89 46 ec 		mov	WORD PTR [bp-20],ax	;xfer_phys
	*** 000271	89 56 ee 		mov	WORD PTR [bp-18],dx
;|***    newreq->pbuffer = phys_to_gdt(xfer_phys,req->pbuf_len,gdt_selector[2]);
; Line 283
	*** 000274	ff 36 04 00 		push	WORD PTR _gdt_selector+4
	*** 000278	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 00027b	26 ff 77 19 		push	WORD PTR es:[bx+25]
	*** 00027f	ff 76 ee 		push	WORD PTR [bp-18]
	*** 000282	ff 76 ec 		push	WORD PTR [bp-20]	;xfer_phys
	*** 000285	9a 00 00 00 00 		call	FAR PTR _phys_to_gdt
	*** 00028a	83 c4 08 		add	sp,8
	*** 00028d	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 000290	26 89 47 0f 		mov	WORD PTR es:[bx+15],ax
	*** 000294	26 89 57 11 		mov	WORD PTR es:[bx+17],dx
;|*** 
;|***    /* Convert the Data buffer pointer to a GDT based address and store in */
;|***    /* the new request packet, after locking it */
;|***    d_lock = lock(newreq->dbuffer._segadr.segment);
; Line 287
	*** 000298	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 00029b	26 ff 77 15 		push	WORD PTR es:[bx+21]
	*** 00029f	9a 00 00 00 00 		call	FAR PTR _lock
	*** 0002a4	83 c4 02 		add	sp,2
	*** 0002a7	89 46 e0 		mov	WORD PTR [bp-32],ax	;d_lock
	*** 0002aa	89 56 e2 		mov	WORD PTR [bp-30],dx
;|***    sense_phys      = get_phys_addr(req->dbuffer);
; Line 288
	*** 0002ad	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0002b0	26 ff 77 15 		push	WORD PTR es:[bx+21]
	*** 0002b4	26 ff 77 13 		push	WORD PTR es:[bx+19]
	*** 0002b8	9a 00 00 00 00 		call	FAR PTR _get_phys_addr
	*** 0002bd	83 c4 04 		add	sp,4
	*** 0002c0	89 46 f8 		mov	WORD PTR [bp-8],ax	;sense_phys
	*** 0002c3	89 56 fa 		mov	WORD PTR [bp-6],dx
;|***    newreq->dbuffer = phys_to_gdt(sense_phys,req->dbuf_len,gdt_selector[3]);
; Line 289
	*** 0002c6	ff 36 06 00 		push	WORD PTR _gdt_selector+6
	*** 0002ca	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0002cd	26 ff 77 1b 		push	WORD PTR es:[bx+27]
	*** 0002d1	ff 76 fa 		push	WORD PTR [bp-6]
	*** 0002d4	ff 76 f8 		push	WORD PTR [bp-8]	;sense_phys
	*** 0002d7	9a 00 00 00 00 		call	FAR PTR _phys_to_gdt
	*** 0002dc	83 c4 08 		add	sp,8
	*** 0002df	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 0002e2	26 89 47 13 		mov	WORD PTR es:[bx+19],ax
	*** 0002e6	26 89 57 15 		mov	WORD PTR es:[bx+21],dx
;|*** 
;|***    /* Set the File handle to the SCSI DD's handle */
;|***    newreq->file_number           = handle;
; Line 292
	*** 0002ea	a1 00 00 		mov	ax,WORD PTR _handle
	*** 0002ed	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 0002f0	26 89 47 17 		mov	WORD PTR es:[bx+23],ax
;|*** 
;|***    /* Call the SCSI DD */
;|***    call_idc(idc_entry,(void *)newreq, scsi_idc.prot_DS);
; Line 295
	*** 0002f4	ff 36 0a 00 		push	WORD PTR _scsi_idc+10
	*** 0002f8	ff 76 f6 		push	WORD PTR [bp-10]
	*** 0002fb	ff 76 f4 		push	WORD PTR [bp-12]	;newreq
	*** 0002fe	ff 36 02 00 		push	WORD PTR _idc_entry+2
	*** 000302	ff 36 00 00 		push	WORD PTR _idc_entry
	*** 000306	9a 00 00 00 00 		call	FAR PTR _call_idc
	*** 00030b	83 c4 0a 		add	sp,10
;|*** 
;|***    /* Copy the request packet status to the original status */
;|***    req->request_hdr.rh_stat   = newreq->request_hdr.rh_stat;
; Line 298
	*** 00030e	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 000311	26 8b 47 03 		mov	ax,WORD PTR es:[bx+3]
	*** 000315	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000318	26 89 47 03 		mov	WORD PTR es:[bx+3],ax
;|***    req->pbuf_len              = newreq->pbuf_len;
; Line 299
	*** 00031c	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 00031f	26 8b 47 19 		mov	ax,WORD PTR es:[bx+25]
	*** 000323	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000326	26 89 47 19 		mov	WORD PTR es:[bx+25],ax
;|***    req->dbuf_len              = newreq->dbuf_len;
; Line 300
	*** 00032a	c4 5e f4 		les	bx,DWORD PTR [bp-12]	;newreq
	*** 00032d	26 8b 47 1b 		mov	ax,WORD PTR es:[bx+27]
	*** 000331	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000334	26 89 47 1b 		mov	WORD PTR es:[bx+27],ax
;|*** 
;|***    /* Return the request packet to the OS */
;|***    free_req(temp);
; Line 303
	*** 000338	ff 76 f2 		push	WORD PTR [bp-14]
	*** 00033b	ff 76 f0 		push	WORD PTR [bp-16]	;temp
	*** 00033e	9a 00 00 00 00 		call	FAR PTR _free_req
	*** 000343	83 c4 04 		add	sp,4
;|*** 
;|***    /* If it worked */
;|***    if (req->request_hdr.rh_stat == DONE) {
; Line 306
	*** 000346	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000349	26 81 7f 03 00 01 	cmp	WORD PTR es:[bx+3],256
	*** 00034f	74 03 			je	$JCC847
	*** 000351	e9 80 00 		jmp	$I1288
					$JCC847:
;|*** 
;|***       /* If it was an ALLOCATE DEVICE */
;|***       if ((req->funct_cat == 0x80) && (req->funct_cod == 0x55)) {
; Line 309
	*** 000354	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000357	26 80 7f 0d 80 		cmp	BYTE PTR es:[bx+13],128
	*** 00035c	74 03 			je	$JCC860
	*** 00035e	e9 33 00 		jmp	$I1289
					$JCC860:
	*** 000361	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000364	26 80 7f 0e 55 		cmp	BYTE PTR es:[bx+14],85
	*** 000369	74 03 			je	$JCC873
	*** 00036b	e9 26 00 		jmp	$I1289
					$JCC873:
;|*** 
;|***          /* Add the device handle to the OPEN record for this handle */
;|***          dhandle = (word *)req->dbuffer.fptr;
; Line 312
	*** 00036e	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000371	26 8b 47 13 		mov	ax,WORD PTR es:[bx+19]
	*** 000375	26 8b 57 15 		mov	dx,WORD PTR es:[bx+21]
	*** 000379	89 46 fc 		mov	WORD PTR [bp-4],ax	;dhandle
	*** 00037c	89 56 fe 		mov	WORD PTR [bp-2],dx
;|***          set_new_devh(req->file_number,*dhandle);
; Line 313
	*** 00037f	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;dhandle
	*** 000382	26 ff 37 		push	WORD PTR es:[bx]
	*** 000385	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000388	26 ff 77 17 		push	WORD PTR es:[bx+23]
	*** 00038c	9a 00 00 00 00 		call	FAR PTR _set_new_devh
	*** 000391	83 c4 04 		add	sp,4
;|***          }
; Line 314
;|*** 
;|***       /* If it was a FREE DEVICE */
;|***       if ((req->funct_cat == 0x80) && (req->funct_cod == 0x54)) {
; Line 317
					$I1289:
	*** 000394	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 000397	26 80 7f 0d 80 		cmp	BYTE PTR es:[bx+13],128
	*** 00039c	74 03 			je	$JCC924
	*** 00039e	e9 33 00 		jmp	$I1290
					$JCC924:
	*** 0003a1	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0003a4	26 80 7f 0e 54 		cmp	BYTE PTR es:[bx+14],84
	*** 0003a9	74 03 			je	$JCC937
	*** 0003ab	e9 26 00 		jmp	$I1290
					$JCC937:
;|*** 
;|***          /* Remove the device handle from the OPEN record for this handle */
;|***          dhandle = (word *)req->pbuffer.fptr;
; Line 320
	*** 0003ae	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0003b1	26 8b 47 0f 		mov	ax,WORD PTR es:[bx+15]
	*** 0003b5	26 8b 57 11 		mov	dx,WORD PTR es:[bx+17]
	*** 0003b9	89 46 fc 		mov	WORD PTR [bp-4],ax	;dhandle
	*** 0003bc	89 56 fe 		mov	WORD PTR [bp-2],dx
;|***          delete_devh(req->file_number,*dhandle);
; Line 321
	*** 0003bf	c4 5e fc 		les	bx,DWORD PTR [bp-4]	;dhandle
	*** 0003c2	26 ff 37 		push	WORD PTR es:[bx]
	*** 0003c5	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0003c8	26 ff 77 17 		push	WORD PTR es:[bx+23]
	*** 0003cc	9a 00 00 00 00 		call	FAR PTR _delete_devh
	*** 0003d1	83 c4 04 		add	sp,4
;|***          }
; Line 322
;|***       }
; Line 323
					$I1290:
;|*** 
;|***    /* Unlock the buffers */
;|***    unlock(p_lock);
; Line 326
					$I1288:
	*** 0003d4	ff 76 ea 		push	WORD PTR [bp-22]
	*** 0003d7	ff 76 e8 		push	WORD PTR [bp-24]	;p_lock
	*** 0003da	9a 00 00 00 00 		call	FAR PTR _unlock
	*** 0003df	83 c4 04 		add	sp,4
;|***    unlock(d_lock);
; Line 327
	*** 0003e2	ff 76 e2 		push	WORD PTR [bp-30]
	*** 0003e5	ff 76 e0 		push	WORD PTR [bp-32]	;d_lock
	*** 0003e8	9a 00 00 00 00 		call	FAR PTR _unlock
	*** 0003ed	83 c4 04 		add	sp,4
;|*** 
;|***    /* Devdone the packet  */
;|***    return(req->request_hdr.rh_stat);
; Line 330
	*** 0003f0	c4 5e e4 		les	bx,DWORD PTR [bp-28]	;req
	*** 0003f3	26 8b 47 03 		mov	ax,WORD PTR es:[bx+3]
	*** 0003f7	e9 00 00 		jmp	$EX1273
;|*** 
;|*** }
; Line 332
					$EX1273:
	*** 0003fa	5e 			pop	si
	*** 0003fb	5f 			pop	di
	*** 0003fc	8b e5 			mov	sp,bp
	*** 0003fe	5d 			pop	bp
	*** 0003ff	cb 			ret	

_call_scsi	ENDP
;|*** 
;|*** word far transfer_scb(reqhdr_type *in_req)
;|*** {
; Line 335
	PUBLIC	_transfer_scb
_transfer_scb	PROC FAR
	*** 000400	55 			push	bp
	*** 000401	8b ec 			mov	bp,sp
	*** 000403	81 ec d4 00 		sub	sp,212
	*** 000407	57 			push	di
	*** 000408	56 			push	si
;	newreq = -24
;	req = -60
;	temp = -36
;	p_lock = -56
;	d_lock = -198
;	scb_lock = -6
;	scb_hdr_phys = -52
;	sense_phys = -18
;	xfer_phys = -48
;	sys_lock = -40
;	tsb_lock = -14
;	sys_virt = -28
;	tsb_virt = -202
;	scb_virt = -194
;	xfer = -32
;	hdr = -206
;	scb = -44
;	pagelist = -190
;	sys_lin = -10
;	page_lin = -212
;	i = -62
;	end_found = -20
;	last_page = -2
;	command = -208
;	in_req = 6
;|***    ioctl_hdr2    *newreq;
;|***    ioctl_hdr2    *req;
;|***    _32bits        temp;
;|***    unsigned long  p_lock;
;|***    unsigned long  d_lock;
;|***    unsigned long  scb_lock;
;|***    _32bits        scb_hdr_phys;
;|***    _32bits        sense_phys;
;|***    _32bits        xfer_phys;
;|***    unsigned long  sys_lock;
;|***    unsigned long  tsb_lock;
;|***    _32bits        sys_virt;
;|***    _32bits        tsb_virt;
;|***    _32bits        scb_virt;
;|***    xfer_scb_type *xfer;
;|***    scb_hdr_type  *hdr;
;|***    scb_type      *scb;
;|***    pagelist_type  pagelist[16];
;|***    _32bits        sys_lin;
;|***    _32bits        page_lin;
;|***    int            i,end_found,last_page;
;|***    int            command;
;|*** 
;|***    /* Cast the request header */
;|***    req = (ioctl_hdr2 *)in_req;
; Line 360
	*** 000409	8b 46 06 		mov	ax,WORD PTR [bp+6]	;in_req
	*** 00040c	8b 56 08 		mov	dx,WORD PTR [bp+8]
	*** 00040f	89 46 c4 		mov	WORD PTR [bp-60],ax	;req
	*** 000412	89 56 c6 		mov	WORD PTR [bp-58],dx
;|*** 
;|***    /* Make a request packet, exiting if failure */
;|***    temp = alloc_req();
; Line 363
	*** 000415	9a 00 00 00 00 		call	FAR PTR _alloc_req
	*** 00041a	89 46 dc 		mov	WORD PTR [bp-36],ax	;temp
	*** 00041d	89 56 de 		mov	WORD PTR [bp-34],dx
;|***    if (temp.phys) newreq = (ioctl_hdr2 *)temp.fptr;
; Line 364
	*** 000420	8b 46 de 		mov	ax,WORD PTR [bp-34]
	*** 000423	0b 46 dc 		or	ax,WORD PTR [bp-36]	;temp
	*** 000426	75 03 			jne	$JCC1062
	*** 000428	e9 0f 00 		jmp	$I1317
					$JCC1062:
	*** 00042b	8b 46 dc 		mov	ax,WORD PTR [bp-36]	;temp
	*** 00042e	8b 56 de 		mov	dx,WORD PTR [bp-34]
	*** 000431	89 46 e8 		mov	WORD PTR [bp-24],ax	;newreq
	*** 000434	89 56 ea 		mov	WORD PTR [bp-22],dx
;|***    else { return(ERROR+DONE+GEN_FAIL); }
; Line 365
	*** 000437	e9 06 00 		jmp	$I1318
					$I1317:
	*** 00043a	b8 0c 81 		mov	ax,-32500
	*** 00043d	e9 ef 04 		jmp	$EX1292
					$I1318:
;|*** 
;|***    /* Copy the parms from the first to the new one */
;|***    newreq->request_hdr.rh_len    = req->request_hdr.rh_len;
; Line 368
	*** 000440	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 000443	26 8a 07 		mov	al,BYTE PTR es:[bx]
	*** 000446	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 000449	26 88 07 		mov	BYTE PTR es:[bx],al
;|***    newreq->request_hdr.rh_unit   = req->request_hdr.rh_unit;
; Line 369
	*** 00044c	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 00044f	26 8a 47 01 		mov	al,BYTE PTR es:[bx+1]
	*** 000453	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 000456	26 88 47 01 		mov	BYTE PTR es:[bx+1],al
;|***    newreq->request_hdr.rh_cmd    = req->request_hdr.rh_cmd;
; Line 370
	*** 00045a	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 00045d	26 8a 47 02 		mov	al,BYTE PTR es:[bx+2]
	*** 000461	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 000464	26 88 47 02 		mov	BYTE PTR es:[bx+2],al
;|***    newreq->request_hdr.rh_stat   = req->request_hdr.rh_stat;
; Line 371
	*** 000468	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 00046b	26 8b 47 03 		mov	ax,WORD PTR es:[bx+3]
	*** 00046f	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 000472	26 89 47 03 		mov	WORD PTR es:[bx+3],ax
;|***    newreq->request_hdr.rh_resrvd = req->request_hdr.rh_resrvd;
; Line 372
	*** 000476	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 000479	26 8b 47 05 		mov	ax,WORD PTR es:[bx+5]
	*** 00047d	26 8b 57 07 		mov	dx,WORD PTR es:[bx+7]
	*** 000481	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 000484	26 89 47 05 		mov	WORD PTR es:[bx+5],ax
	*** 000488	26 89 57 07 		mov	WORD PTR es:[bx+7],dx
;|***    newreq->request_hdr.rh_next   = req->request_hdr.rh_next;
; Line 373
	*** 00048c	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 00048f	26 8b 47 09 		mov	ax,WORD PTR es:[bx+9]
	*** 000493	26 8b 57 0b 		mov	dx,WORD PTR es:[bx+11]
	*** 000497	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 00049a	26 89 47 09 		mov	WORD PTR es:[bx+9],ax
	*** 00049e	26 89 57 0b 		mov	WORD PTR es:[bx+11],dx
;|***    newreq->funct_cat             = req->funct_cat;
; Line 374
	*** 0004a2	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 0004a5	26 8a 47 0d 		mov	al,BYTE PTR es:[bx+13]
	*** 0004a9	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 0004ac	26 88 47 0d 		mov	BYTE PTR es:[bx+13],al
;|***    newreq->funct_cod             = req->funct_cod;
; Line 375
	*** 0004b0	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 0004b3	26 8a 47 0e 		mov	al,BYTE PTR es:[bx+14]
	*** 0004b7	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 0004ba	26 88 47 0e 		mov	BYTE PTR es:[bx+14],al
;|***    newreq->pbuf_len              = req->pbuf_len;
; Line 376
	*** 0004be	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 0004c1	26 8b 47 19 		mov	ax,WORD PTR es:[bx+25]
	*** 0004c5	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 0004c8	26 89 47 19 		mov	WORD PTR es:[bx+25],ax
;|***    newreq->dbuf_len              = req->dbuf_len;
; Line 377
	*** 0004cc	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 0004cf	26 8b 47 1b 		mov	ax,WORD PTR es:[bx+27]
	*** 0004d3	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 0004d6	26 89 47 1b 		mov	WORD PTR es:[bx+27],ax
;|***    newreq->file_number           = handle;
; Line 378
	*** 0004da	a1 00 00 		mov	ax,WORD PTR _handle
	*** 0004dd	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 0004e0	26 89 47 17 		mov	WORD PTR es:[bx+23],ax
;|*** 
;|***    /* Deal first with the data buffer pointer.  It points to the Sense data */
;|***    /* First, lock it, then get the physical address, then make a GDT pointer */
;|***    /* to it and store that pointer in the new request packet */
;|***    d_lock          = lock(req->dbuffer._segadr.segment);
; Line 383
	*** 0004e4	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 0004e7	26 ff 77 15 		push	WORD PTR es:[bx+21]
	*** 0004eb	9a 00 00 00 00 		call	FAR PTR _lock
	*** 0004f0	83 c4 02 		add	sp,2
	*** 0004f3	89 86 3a ff 		mov	WORD PTR [bp-198],ax	;d_lock
	*** 0004f7	89 96 3c ff 		mov	WORD PTR [bp-196],dx
;|***    sense_phys      = get_phys_addr(req->dbuffer);
; Line 384
	*** 0004fb	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 0004fe	26 ff 77 15 		push	WORD PTR es:[bx+21]
	*** 000502	26 ff 77 13 		push	WORD PTR es:[bx+19]
	*** 000506	9a 00 00 00 00 		call	FAR PTR _get_phys_addr
	*** 00050b	83 c4 04 		add	sp,4
	*** 00050e	89 46 ee 		mov	WORD PTR [bp-18],ax	;sense_phys
	*** 000511	89 56 f0 		mov	WORD PTR [bp-16],dx
;|***    newreq->dbuffer = phys_to_gdt(sense_phys,req->dbuf_len,gdt_selector[3]);
; Line 385
	*** 000514	ff 36 06 00 		push	WORD PTR _gdt_selector+6
	*** 000518	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 00051b	26 ff 77 1b 		push	WORD PTR es:[bx+27]
	*** 00051f	ff 76 f0 		push	WORD PTR [bp-16]
	*** 000522	ff 76 ee 		push	WORD PTR [bp-18]	;sense_phys
	*** 000525	9a 00 00 00 00 		call	FAR PTR _phys_to_gdt
	*** 00052a	83 c4 08 		add	sp,8
	*** 00052d	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 000530	26 89 47 13 		mov	WORD PTR es:[bx+19],ax
	*** 000534	26 89 57 15 		mov	WORD PTR es:[bx+21],dx
;|*** 
;|***    /* Now, do the same for the PARM buffer pointer - it is the Transfer SCB */
;|***    p_lock          = lock(req->pbuffer._segadr.segment);
; Line 388
	*** 000538	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 00053b	26 ff 77 11 		push	WORD PTR es:[bx+17]
	*** 00053f	9a 00 00 00 00 		call	FAR PTR _lock
	*** 000544	83 c4 02 		add	sp,2
	*** 000547	89 46 c8 		mov	WORD PTR [bp-56],ax	;p_lock
	*** 00054a	89 56 ca 		mov	WORD PTR [bp-54],dx
;|***    xfer_phys       = get_phys_addr(req->pbuffer);
; Line 389
	*** 00054d	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 000550	26 ff 77 11 		push	WORD PTR es:[bx+17]
	*** 000554	26 ff 77 0f 		push	WORD PTR es:[bx+15]
	*** 000558	9a 00 00 00 00 		call	FAR PTR _get_phys_addr
	*** 00055d	83 c4 04 		add	sp,4
	*** 000560	89 46 d0 		mov	WORD PTR [bp-48],ax	;xfer_phys
	*** 000563	89 56 d2 		mov	WORD PTR [bp-46],dx
;|***    newreq->pbuffer = phys_to_gdt(xfer_phys,req->pbuf_len,gdt_selector[2]);
; Line 390
	*** 000566	ff 36 04 00 		push	WORD PTR _gdt_selector+4
	*** 00056a	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 00056d	26 ff 77 19 		push	WORD PTR es:[bx+25]
	*** 000571	ff 76 d2 		push	WORD PTR [bp-46]
	*** 000574	ff 76 d0 		push	WORD PTR [bp-48]	;xfer_phys
	*** 000577	9a 00 00 00 00 		call	FAR PTR _phys_to_gdt
	*** 00057c	83 c4 08 		add	sp,8
	*** 00057f	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 000582	26 89 47 0f 		mov	WORD PTR es:[bx+15],ax
	*** 000586	26 89 57 11 		mov	WORD PTR es:[bx+17],dx
;|*** 
;|***    /* Make some pointers for speed */
;|***    xfer = (xfer_scb_type *)req->pbuffer.fptr;
; Line 393
	*** 00058a	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 00058d	26 8b 47 0f 		mov	ax,WORD PTR es:[bx+15]
	*** 000591	26 8b 57 11 		mov	dx,WORD PTR es:[bx+17]
	*** 000595	89 46 e0 		mov	WORD PTR [bp-32],ax	;xfer
	*** 000598	89 56 e2 		mov	WORD PTR [bp-30],dx
;|***    hdr =  (scb_hdr_type *)xfer->scb_header.fptr;
; Line 394
	*** 00059b	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;xfer
	*** 00059e	26 8b 47 08 		mov	ax,WORD PTR es:[bx+8]
	*** 0005a2	26 8b 57 0a 		mov	dx,WORD PTR es:[bx+10]
	*** 0005a6	89 86 32 ff 		mov	WORD PTR [bp-206],ax	;hdr
	*** 0005aa	89 96 34 ff 		mov	WORD PTR [bp-204],dx
;|***    scb = (scb_type *)&hdr->scb;
; Line 395
	*** 0005ae	8b 86 32 ff 		mov	ax,WORD PTR [bp-206]	;hdr
	*** 0005b2	8b 96 34 ff 		mov	dx,WORD PTR [bp-204]
	*** 0005b6	05 10 00 		add	ax,16
	*** 0005b9	89 46 d4 		mov	WORD PTR [bp-44],ax	;scb
	*** 0005bc	89 56 d6 		mov	WORD PTR [bp-42],dx
;|*** 
;|***    /* SCB header pointer in the transfer SCB - do the same trick as with  */
;|***    /* the parm buffer and data buffer - lock, get physical address and    */
;|***    /* replace the the pointer in the transfer SCB with the GDT based      */
;|***    /* equivalent.  The only difference this time is that we save the LDT  */
;|***    /* based pointer for replacement after we are done.                    */
;|***    scb_lock         = lock(xfer->scb_header._segadr.segment);
; Line 402
	*** 0005bf	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;xfer
	*** 0005c2	26 ff 77 0a 		push	WORD PTR es:[bx+10]
	*** 0005c6	9a 00 00 00 00 		call	FAR PTR _lock
	*** 0005cb	83 c4 02 		add	sp,2
	*** 0005ce	89 46 fa 		mov	WORD PTR [bp-6],ax	;scb_lock
	*** 0005d1	89 56 fc 		mov	WORD PTR [bp-4],dx
;|***    scb_virt         = xfer->scb_header;
; Line 403
	*** 0005d4	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;xfer
	*** 0005d7	26 8b 47 08 		mov	ax,WORD PTR es:[bx+8]
	*** 0005db	26 8b 57 0a 		mov	dx,WORD PTR es:[bx+10]
	*** 0005df	89 86 3e ff 		mov	WORD PTR [bp-194],ax	;scb_virt
	*** 0005e3	89 96 40 ff 		mov	WORD PTR [bp-192],dx
;|***    scb_hdr_phys     = get_phys_addr(xfer->scb_header);
; Line 404
	*** 0005e7	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;xfer
	*** 0005ea	26 ff 77 0a 		push	WORD PTR es:[bx+10]
	*** 0005ee	26 ff 77 08 		push	WORD PTR es:[bx+8]
	*** 0005f2	9a 00 00 00 00 		call	FAR PTR _get_phys_addr
	*** 0005f7	83 c4 04 		add	sp,4
	*** 0005fa	89 46 cc 		mov	WORD PTR [bp-52],ax	;scb_hdr_phys
	*** 0005fd	89 56 ce 		mov	WORD PTR [bp-50],dx
;|***    xfer->scb_header = phys_to_gdt(scb_hdr_phys,
;|***                                   sizeof(long_scb_hdr_type),
;|***                                   gdt_selector[1]);
; Line 407
	*** 000600	ff 36 02 00 		push	WORD PTR _gdt_selector+2
	*** 000604	b8 34 00 		mov	ax,52
	*** 000607	50 			push	ax
	*** 000608	ff 76 ce 		push	WORD PTR [bp-50]
	*** 00060b	ff 76 cc 		push	WORD PTR [bp-52]	;scb_hdr_phys
	*** 00060e	9a 00 00 00 00 		call	FAR PTR _phys_to_gdt
	*** 000613	83 c4 08 		add	sp,8
	*** 000616	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;xfer
	*** 000619	26 89 47 08 		mov	WORD PTR es:[bx+8],ax
	*** 00061d	26 89 57 0a 		mov	WORD PTR es:[bx+10],dx
;|*** 
;|***    /* Now, store a physical pointer to the SCB in the header */
;|***    temp.fptr                 = (void far *)&hdr->scb;
; Line 410
	*** 000621	8b 86 32 ff 		mov	ax,WORD PTR [bp-206]	;hdr
	*** 000625	8b 96 34 ff 		mov	dx,WORD PTR [bp-204]
	*** 000629	05 10 00 		add	ax,16
	*** 00062c	89 46 dc 		mov	WORD PTR [bp-36],ax	;temp
	*** 00062f	89 56 de 		mov	WORD PTR [bp-34],dx
;|***    xfer->scb_phys            = get_phys_addr(temp);
; Line 411
	*** 000632	ff 76 de 		push	WORD PTR [bp-34]
	*** 000635	ff 76 dc 		push	WORD PTR [bp-36]	;temp
	*** 000638	9a 00 00 00 00 		call	FAR PTR _get_phys_addr
	*** 00063d	83 c4 04 		add	sp,4
	*** 000640	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;xfer
	*** 000643	26 89 47 04 		mov	WORD PTR es:[bx+4],ax
	*** 000647	26 89 57 06 		mov	WORD PTR es:[bx+6],dx
;|*** 
;|***    /* Now do it for the TSB                                              */
;|***    tsb_lock         = lock(hdr->scb.tsb_adr._segadr.segment);
; Line 414
	*** 00064b	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 00064f	26 ff 77 22 		push	WORD PTR es:[bx+34]
	*** 000653	9a 00 00 00 00 		call	FAR PTR _lock
	*** 000658	83 c4 02 		add	sp,2
	*** 00065b	89 46 f2 		mov	WORD PTR [bp-14],ax	;tsb_lock
	*** 00065e	89 56 f4 		mov	WORD PTR [bp-12],dx
;|***    tsb_virt         = hdr->scb.tsb_adr;
; Line 415
	*** 000661	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 000665	26 8b 47 20 		mov	ax,WORD PTR es:[bx+32]
	*** 000669	26 8b 57 22 		mov	dx,WORD PTR es:[bx+34]
	*** 00066d	89 86 36 ff 		mov	WORD PTR [bp-202],ax	;tsb_virt
	*** 000671	89 96 38 ff 		mov	WORD PTR [bp-200],dx
;|***    hdr->scb.tsb_adr = get_phys_addr(tsb_virt);
; Line 416
	*** 000675	ff b6 38 ff 		push	WORD PTR [bp-200]
	*** 000679	ff b6 36 ff 		push	WORD PTR [bp-202]	;tsb_virt
	*** 00067d	9a 00 00 00 00 		call	FAR PTR _get_phys_addr
	*** 000682	83 c4 04 		add	sp,4
	*** 000685	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 000689	26 89 47 20 		mov	WORD PTR es:[bx+32],ax
	*** 00068d	26 89 57 22 		mov	WORD PTR es:[bx+34],dx
;|***    hdr->tsb_adr     = phys_to_gdt(hdr->scb.tsb_adr,100,gdt_selector[0]);
; Line 417
	*** 000691	ff 36 00 00 		push	WORD PTR _gdt_selector
	*** 000695	b8 64 00 		mov	ax,100
	*** 000698	50 			push	ax
	*** 000699	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 00069d	26 ff 77 22 		push	WORD PTR es:[bx+34]
	*** 0006a1	26 ff 77 20 		push	WORD PTR es:[bx+32]
	*** 0006a5	9a 00 00 00 00 		call	FAR PTR _phys_to_gdt
	*** 0006aa	83 c4 08 		add	sp,8
	*** 0006ad	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 0006b1	26 89 47 0a 		mov	WORD PTR es:[bx+10],ax
	*** 0006b5	26 89 57 0c 		mov	WORD PTR es:[bx+12],dx
;|*** 
;|***    /* System buffer - don't need virtual, but physcal address here */
;|***    sys_lock                = lock(hdr->scb.system_buf_adr._segadr.segment);
; Line 420
	*** 0006b9	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 0006bd	26 ff 77 1a 		push	WORD PTR es:[bx+26]
	*** 0006c1	9a 00 00 00 00 		call	FAR PTR _lock
	*** 0006c6	83 c4 02 		add	sp,2
	*** 0006c9	89 46 d8 		mov	WORD PTR [bp-40],ax	;sys_lock
	*** 0006cc	89 56 da 		mov	WORD PTR [bp-38],dx
;|***    sys_virt                = hdr->scb.system_buf_adr;
; Line 421
	*** 0006cf	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 0006d3	26 8b 47 18 		mov	ax,WORD PTR es:[bx+24]
	*** 0006d7	26 8b 57 1a 		mov	dx,WORD PTR es:[bx+26]
	*** 0006db	89 46 e4 		mov	WORD PTR [bp-28],ax	;sys_virt
	*** 0006de	89 56 e6 		mov	WORD PTR [bp-26],dx
;|***    hdr->scb.system_buf_adr = get_phys_addr(sys_virt);
; Line 422
	*** 0006e1	ff 76 e6 		push	WORD PTR [bp-26]
	*** 0006e4	ff 76 e4 		push	WORD PTR [bp-28]	;sys_virt
	*** 0006e7	9a 00 00 00 00 		call	FAR PTR _get_phys_addr
	*** 0006ec	83 c4 04 		add	sp,4
	*** 0006ef	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 0006f3	26 89 47 18 		mov	WORD PTR es:[bx+24],ax
	*** 0006f7	26 89 57 1a 		mov	WORD PTR es:[bx+26],dx
;|*** 
;|***    /* Finally, deal with the scatter/gather problem.                         */
;|***    /* If we are allowed to (the command is right), and we might be able to   */
;|***    /* (there is some data to transfer) and we need to (the buffer spans      */
;|***    /* more than 1 page block), set the scatter/gather list indicator in the  */
;|***    /* SCB and store a physical pointer to the page list in the system byffer */
;|***    /* address.  This meand converting the virtual address first to a linear  */
;|***    /* address and then to a pagelist.  If the pagelist is more than 1 page   */
;|***    /* long, we then tell OS2SCSI that the system buffer is the physical      */
;|***    /* address of the page list instead of the physical addr of the buffer.   */
;|***    command = hdr->scb.command & 0x3f;
; Line 433
	*** 0006fb	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 0006ff	26 8a 47 10 		mov	al,BYTE PTR es:[bx+16]
	*** 000703	25 3f 00 		and	ax,63
	*** 000706	89 86 30 ff 		mov	WORD PTR [bp-208],ax	;command
;|***    if (scb->system_buf_cnt.phys != 0L) {
; Line 434
	*** 00070a	c4 5e d4 		les	bx,DWORD PTR [bp-44]	;scb
	*** 00070d	26 8b 47 0e 		mov	ax,WORD PTR es:[bx+14]
	*** 000711	26 0b 47 0c 		or	ax,WORD PTR es:[bx+12]
	*** 000715	75 03 			jne	$JCC1813
	*** 000717	e9 38 01 		jmp	$I1319
					$JCC1813:
;|***       switch (command) {
; Line 435
	*** 00071a	8b 86 30 ff 		mov	ax,WORD PTR [bp-208]	;command
	*** 00071e	e9 13 01 		jmp	$S1320
;|***          case  1 :
; Line 436
					$SC1324:
;|***          case  2 :
;|***          case  4 :
;|***          case 31 : {
; Line 439
;|***             sys_lin = virt_to_lin(sys_virt);
; Line 440
	*** 000721	ff 76 e6 		push	WORD PTR [bp-26]
	*** 000724	ff 76 e4 		push	WORD PTR [bp-28]	;sys_virt
	*** 000727	9a 00 00 00 00 		call	FAR PTR _virt_to_lin
	*** 00072c	83 c4 04 		add	sp,4
	*** 00072f	89 46 f6 		mov	WORD PTR [bp-10],ax	;sys_lin
	*** 000732	89 56 f8 		mov	WORD PTR [bp-8],dx
;|***             temp.fptr = (void far *)pagelist;
; Line 441
	*** 000735	8d 86 42 ff 		lea	ax,WORD PTR [bp-190]	;pagelist
	*** 000739	89 46 dc 		mov	WORD PTR [bp-36],ax	;temp
	*** 00073c	8c 56 de 		mov	WORD PTR [bp-34],ss
;|***             page_lin = virt_to_lin(temp);
; Line 442
	*** 00073f	ff 76 de 		push	WORD PTR [bp-34]
	*** 000742	ff 76 dc 		push	WORD PTR [bp-36]	;temp
	*** 000745	9a 00 00 00 00 		call	FAR PTR _virt_to_lin
	*** 00074a	83 c4 04 		add	sp,4
	*** 00074d	89 86 2c ff 		mov	WORD PTR [bp-212],ax	;page_lin
	*** 000751	89 96 2e ff 		mov	WORD PTR [bp-210],dx
;|***             for (i=0; i<16; i++) { pagelist[i].page_size = 0; }
; Line 443
	*** 000755	c7 46 c2 00 00 		mov	WORD PTR [bp-62],0	;i
	*** 00075a	e9 03 00 		jmp	$F1325
					$FC1326:
	*** 00075d	ff 46 c2 		inc	WORD PTR [bp-62]	;i
					$F1325:
	*** 000760	83 7e c2 10 		cmp	WORD PTR [bp-62],16	;i
	*** 000764	7c 03 			jl	$JCC1892
	*** 000766	e9 14 00 		jmp	$FB1327
					$JCC1892:
	*** 000769	b1 03 			mov	cl,3
	*** 00076b	8b 76 c2 		mov	si,WORD PTR [bp-62]	;i
	*** 00076e	d3 e6 			shl	si,cl
	*** 000770	2b c0 			sub	ax,ax
	*** 000772	89 82 48 ff 		mov	WORD PTR [bp-184][si],ax
	*** 000776	89 82 46 ff 		mov	WORD PTR [bp-186][si],ax
	*** 00077a	e9 e0 ff 		jmp	$FC1326
					$FB1327:
;|***             lin_to_pages(sys_lin, page_lin,scb->system_buf_cnt);
; Line 444
	*** 00077d	c4 5e d4 		les	bx,DWORD PTR [bp-44]	;scb
	*** 000780	26 ff 77 0e 		push	WORD PTR es:[bx+14]
	*** 000784	26 ff 77 0c 		push	WORD PTR es:[bx+12]
	*** 000788	ff b6 2e ff 		push	WORD PTR [bp-210]
	*** 00078c	ff b6 2c ff 		push	WORD PTR [bp-212]	;page_lin
	*** 000790	ff 76 f8 		push	WORD PTR [bp-8]
	*** 000793	ff 76 f6 		push	WORD PTR [bp-10]	;sys_lin
	*** 000796	9a 00 00 00 00 		call	FAR PTR _lin_to_pages
	*** 00079b	83 c4 0c 		add	sp,12
;|***             end_found = 0;
; Line 445
	*** 00079e	c7 46 ec 00 00 		mov	WORD PTR [bp-20],0	;end_found
;|***             for (i=0; i<16; i++) {
; Line 446
	*** 0007a3	c7 46 c2 00 00 		mov	WORD PTR [bp-62],0	;i
	*** 0007a8	e9 03 00 		jmp	$F1328
					$FC1329:
	*** 0007ab	ff 46 c2 		inc	WORD PTR [bp-62]	;i
					$F1328:
	*** 0007ae	83 7e c2 10 		cmp	WORD PTR [bp-62],16	;i
	*** 0007b2	7c 03 			jl	$JCC1970
	*** 0007b4	e9 1f 00 		jmp	$FB1330
					$JCC1970:
;|***                if (pagelist[i].page_size == 0) {
; Line 447
	*** 0007b7	b1 03 			mov	cl,3
	*** 0007b9	8b 76 c2 		mov	si,WORD PTR [bp-62]	;i
	*** 0007bc	d3 e6 			shl	si,cl
	*** 0007be	8b 82 48 ff 		mov	ax,WORD PTR [bp-184][si]
	*** 0007c2	0b 82 46 ff 		or	ax,WORD PTR [bp-186][si]
	*** 0007c6	74 03 			je	$JCC1990
	*** 0007c8	e9 08 00 		jmp	$I1331
					$JCC1990:
;|***                   end_found = 1;
; Line 448
	*** 0007cb	c7 46 ec 01 00 		mov	WORD PTR [bp-20],1	;end_found
;|***                   break;
; Line 449
	*** 0007d0	e9 03 00 		jmp	$FB1330
;|***                   }
; Line 450
;|***                }
; Line 451
					$I1331:
	*** 0007d3	e9 d5 ff 		jmp	$FC1329
					$FB1330:
;|***             if (end_found) last_page = i;
; Line 452
	*** 0007d6	83 7e ec 00 		cmp	WORD PTR [bp-20],0	;end_found
	*** 0007da	75 03 			jne	$JCC2010
	*** 0007dc	e9 09 00 		jmp	$I1332
					$JCC2010:
	*** 0007df	8b 46 c2 		mov	ax,WORD PTR [bp-62]	;i
	*** 0007e2	89 46 fe 		mov	WORD PTR [bp-2],ax	;last_page
;|***             else           last_page = 16;
; Line 453
	*** 0007e5	e9 05 00 		jmp	$I1333
					$I1332:
	*** 0007e8	c7 46 fe 10 00 		mov	WORD PTR [bp-2],16	;last_page
					$I1333:
;|*** 
;|***             if (i != 1) {
; Line 455
	*** 0007ed	83 7e c2 01 		cmp	WORD PTR [bp-62],1	;i
	*** 0007f1	75 03 			jne	$JCC2033
	*** 0007f3	e9 38 00 		jmp	$I1334
					$JCC2033:
;|***                hdr->scb.system_buf_adr = get_phys_addr(temp);
; Line 456
	*** 0007f6	ff 76 de 		push	WORD PTR [bp-34]
	*** 0007f9	ff 76 dc 		push	WORD PTR [bp-36]	;temp
	*** 0007fc	9a 00 00 00 00 		call	FAR PTR _get_phys_addr
	*** 000801	83 c4 04 		add	sp,4
	*** 000804	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 000808	26 89 47 18 		mov	WORD PTR es:[bx+24],ax
	*** 00080c	26 89 57 1a 		mov	WORD PTR es:[bx+26],dx
;|***                hdr->scb.system_buf_cnt.phys = last_page * sizeof(pagelist_type);
; Line 457
	*** 000810	8b 46 fe 		mov	ax,WORD PTR [bp-2]	;last_page
	*** 000813	b1 03 			mov	cl,3
	*** 000815	d3 e0 			shl	ax,cl
	*** 000817	99 			cwd	
	*** 000818	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 00081c	26 89 47 1c 		mov	WORD PTR es:[bx+28],ax
	*** 000820	26 89 57 1e 		mov	WORD PTR es:[bx+30],dx
;|***                hdr->scb.enable |= 0x1000;
; Line 458
	*** 000824	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 000828	26 81 4f 12 00 10 	or	WORD PTR es:[bx+18],4096
;|***                }
; Line 459
;|***             break;
; Line 460
					$I1334:
	*** 00082e	e9 21 00 		jmp	$SB1321
;|***             }
; Line 461
;|***          }
; Line 462
	*** 000831	e9 1e 00 		jmp	$SB1321
					$S1320:
	*** 000834	48 			dec	ax
	*** 000835	7d 03 			jge	$JCC2101
	*** 000837	e9 18 00 		jmp	$SB1321
					$JCC2101:
	*** 00083a	48 			dec	ax
	*** 00083b	7f 03 			jg	$JCC2107
	*** 00083d	e9 e1 fe 		jmp	$SC1324
					$JCC2107:
	*** 000840	48 			dec	ax
	*** 000841	48 			dec	ax
	*** 000842	75 03 			jne	$JCC2114
	*** 000844	e9 da fe 		jmp	$SC1324
					$JCC2114:
	*** 000847	2d 1b 00 		sub	ax,27
	*** 00084a	75 03 			jne	$JCC2122
	*** 00084c	e9 d2 fe 		jmp	$SC1324
					$JCC2122:
	*** 00084f	e9 00 00 		jmp	$SB1321
					$SB1321:
;|***       }
; Line 463
;|*** 
;|***    /* Call the SCSI DD */
;|***    call_idc(idc_entry,(void *)newreq, scsi_idc.prot_DS);
; Line 466
					$I1319:
	*** 000852	ff 36 0a 00 		push	WORD PTR _scsi_idc+10
	*** 000856	ff 76 ea 		push	WORD PTR [bp-22]
	*** 000859	ff 76 e8 		push	WORD PTR [bp-24]	;newreq
	*** 00085c	ff 36 02 00 		push	WORD PTR _idc_entry+2
	*** 000860	ff 36 00 00 		push	WORD PTR _idc_entry
	*** 000864	9a 00 00 00 00 		call	FAR PTR _call_idc
	*** 000869	83 c4 0a 		add	sp,10
;|*** 
;|***    /* Copy the request packet status to the original status */
;|***    req->request_hdr.rh_stat   = newreq->request_hdr.rh_stat;
; Line 469
	*** 00086c	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 00086f	26 8b 47 03 		mov	ax,WORD PTR es:[bx+3]
	*** 000873	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 000876	26 89 47 03 		mov	WORD PTR es:[bx+3],ax
;|***    req->pbuf_len              = newreq->pbuf_len;
; Line 470
	*** 00087a	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 00087d	26 8b 47 19 		mov	ax,WORD PTR es:[bx+25]
	*** 000881	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 000884	26 89 47 19 		mov	WORD PTR es:[bx+25],ax
;|***    req->dbuf_len              = newreq->dbuf_len;
; Line 471
	*** 000888	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 00088b	26 8b 47 1b 		mov	ax,WORD PTR es:[bx+27]
	*** 00088f	c4 5e c4 		les	bx,DWORD PTR [bp-60]	;req
	*** 000892	26 89 47 1b 		mov	WORD PTR es:[bx+27],ax
;|*** 
;|***    /* Return the request packet to the OS */
;|***    free_req(temp);
; Line 474
	*** 000896	ff 76 de 		push	WORD PTR [bp-34]
	*** 000899	ff 76 dc 		push	WORD PTR [bp-36]	;temp
	*** 00089c	9a 00 00 00 00 		call	FAR PTR _free_req
	*** 0008a1	83 c4 04 		add	sp,4
;|*** 
;|***    /* Put the virtual addresses back */
;|***    hdr->scb.system_buf_adr = sys_virt;
; Line 477
	*** 0008a4	8b 46 e4 		mov	ax,WORD PTR [bp-28]	;sys_virt
	*** 0008a7	8b 56 e6 		mov	dx,WORD PTR [bp-26]
	*** 0008aa	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 0008ae	26 89 47 18 		mov	WORD PTR es:[bx+24],ax
	*** 0008b2	26 89 57 1a 		mov	WORD PTR es:[bx+26],dx
;|***    hdr->scb.tsb_adr        = tsb_virt;
; Line 478
	*** 0008b6	8b 86 36 ff 		mov	ax,WORD PTR [bp-202]	;tsb_virt
	*** 0008ba	8b 96 38 ff 		mov	dx,WORD PTR [bp-200]
	*** 0008be	c4 9e 32 ff 		les	bx,DWORD PTR [bp-206]	;hdr
	*** 0008c2	26 89 47 20 		mov	WORD PTR es:[bx+32],ax
	*** 0008c6	26 89 57 22 		mov	WORD PTR es:[bx+34],dx
;|***    xfer->scb_header        = scb_virt;
; Line 479
	*** 0008ca	8b 86 3e ff 		mov	ax,WORD PTR [bp-194]	;scb_virt
	*** 0008ce	8b 96 40 ff 		mov	dx,WORD PTR [bp-192]
	*** 0008d2	c4 5e e0 		les	bx,DWORD PTR [bp-32]	;xfer
	*** 0008d5	26 89 47 08 		mov	WORD PTR es:[bx+8],ax
	*** 0008d9	26 89 57 0a 		mov	WORD PTR es:[bx+10],dx
;|*** 
;|***    /* Unlock the buffers */
;|***    unlock(p_lock);
; Line 482
	*** 0008dd	ff 76 ca 		push	WORD PTR [bp-54]
	*** 0008e0	ff 76 c8 		push	WORD PTR [bp-56]	;p_lock
	*** 0008e3	9a 00 00 00 00 		call	FAR PTR _unlock
	*** 0008e8	83 c4 04 		add	sp,4
;|***    unlock(d_lock);
; Line 483
	*** 0008eb	ff b6 3c ff 		push	WORD PTR [bp-196]
	*** 0008ef	ff b6 3a ff 		push	WORD PTR [bp-198]	;d_lock
	*** 0008f3	9a 00 00 00 00 		call	FAR PTR _unlock
	*** 0008f8	83 c4 04 		add	sp,4
;|***    unlock(scb_lock);
; Line 484
	*** 0008fb	ff 76 fc 		push	WORD PTR [bp-4]
	*** 0008fe	ff 76 fa 		push	WORD PTR [bp-6]	;scb_lock
	*** 000901	9a 00 00 00 00 		call	FAR PTR _unlock
	*** 000906	83 c4 04 		add	sp,4
;|***    unlock(sys_lock);
; Line 485
	*** 000909	ff 76 da 		push	WORD PTR [bp-38]
	*** 00090c	ff 76 d8 		push	WORD PTR [bp-40]	;sys_lock
	*** 00090f	9a 00 00 00 00 		call	FAR PTR _unlock
	*** 000914	83 c4 04 		add	sp,4
;|***    unlock(tsb_lock);
; Line 486
	*** 000917	ff 76 f4 		push	WORD PTR [bp-12]
	*** 00091a	ff 76 f2 		push	WORD PTR [bp-14]	;tsb_lock
	*** 00091d	9a 00 00 00 00 		call	FAR PTR _unlock
	*** 000922	83 c4 04 		add	sp,4
;|*** 
;|***    /* Devdone the packet  */
;|***    return(newreq->request_hdr.rh_stat);
; Line 489
	*** 000925	c4 5e e8 		les	bx,DWORD PTR [bp-24]	;newreq
	*** 000928	26 8b 47 03 		mov	ax,WORD PTR es:[bx+3]
	*** 00092c	e9 00 00 		jmp	$EX1292
;|*** 
;|*** }
; Line 491
					$EX1292:
	*** 00092f	5e 			pop	si
	*** 000930	5f 			pop	di
	*** 000931	8b e5 			mov	sp,bp
	*** 000933	5d 			pop	bp
	*** 000934	cb 			ret	

_transfer_scb	ENDP
;|*** 
;|*** word far free_dhand(word dhandle)
;|*** {
; Line 494
	PUBLIC	_free_dhand
_free_dhand	PROC FAR
	*** 000935	55 			push	bp
	*** 000936	8b ec 			mov	bp,sp
	*** 000938	81 ec 12 00 		sub	sp,18
	*** 00093c	57 			push	di
	*** 00093d	56 			push	si
;	newreq = -8
;	temp = -12
;	temp1 = -16
;	pbuf_phys = -4
;	pbuf = -18
;	dhandle = 6
;|***    ioctl_hdr2    *newreq;
;|***    _32bits        temp;
;|***    _32bits        temp1;
;|***    _32bits        pbuf_phys;
;|***    word           pbuf;
;|*** 
;|***    /* Make a request packet */
;|***    temp = alloc_req();
; Line 502
	*** 00093e	9a 00 00 00 00 		call	FAR PTR _alloc_req
	*** 000943	89 46 f4 		mov	WORD PTR [bp-12],ax	;temp
	*** 000946	89 56 f6 		mov	WORD PTR [bp-10],dx
;|***    if (temp.phys) newreq = (ioctl_hdr2 *)temp.fptr;
; Line 503
	*** 000949	8b 46 f6 		mov	ax,WORD PTR [bp-10]
	*** 00094c	0b 46 f4 		or	ax,WORD PTR [bp-12]	;temp
	*** 00094f	75 03 			jne	$JCC2383
	*** 000951	e9 0c 00 		jmp	$I1342
					$JCC2383:
	*** 000954	8b 46 f4 		mov	ax,WORD PTR [bp-12]	;temp
	*** 000957	8b 56 f6 		mov	dx,WORD PTR [bp-10]
	*** 00095a	89 46 f8 		mov	WORD PTR [bp-8],ax	;newreq
	*** 00095d	89 56 fa 		mov	WORD PTR [bp-6],dx
;|*** 
;|***    /* Get some physical addresses */
;|***    temp1.fptr =(void far *)&pbuf;
; Line 506
					$I1342:
	*** 000960	8d 46 ee 		lea	ax,WORD PTR [bp-18]	;pbuf
	*** 000963	89 46 f0 		mov	WORD PTR [bp-16],ax	;temp1
	*** 000966	8c 56 f2 		mov	WORD PTR [bp-14],ss
;|***    pbuf_phys = get_phys_addr(temp1);
; Line 507
	*** 000969	ff 76 f2 		push	WORD PTR [bp-14]
	*** 00096c	ff 76 f0 		push	WORD PTR [bp-16]	;temp1
	*** 00096f	9a 00 00 00 00 		call	FAR PTR _get_phys_addr
	*** 000974	83 c4 04 		add	sp,4
	*** 000977	89 46 fc 		mov	WORD PTR [bp-4],ax	;pbuf_phys
	*** 00097a	89 56 fe 		mov	WORD PTR [bp-2],dx
;|*** 
;|***    /* Copy the parms from the first to the new one */
;|***    newreq->request_hdr.rh_len    = 0x19;
; Line 510
	*** 00097d	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 000980	26 c6 07 19 		mov	BYTE PTR es:[bx],25
;|***    newreq->request_hdr.rh_unit   = 0;
; Line 511
	*** 000984	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 000987	26 c6 47 01 00 		mov	BYTE PTR es:[bx+1],0
;|***    newreq->request_hdr.rh_cmd    = 0x10;
; Line 512
	*** 00098c	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 00098f	26 c6 47 02 10 		mov	BYTE PTR es:[bx+2],16
;|***    newreq->request_hdr.rh_stat   = 0;
; Line 513
	*** 000994	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 000997	26 c7 47 03 00 00 	mov	WORD PTR es:[bx+3],0
;|***    newreq->request_hdr.rh_resrvd = 0L;
; Line 514
	*** 00099d	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 0009a0	2b c0 			sub	ax,ax
	*** 0009a2	26 89 47 07 		mov	WORD PTR es:[bx+7],ax
	*** 0009a6	26 89 47 05 		mov	WORD PTR es:[bx+5],ax
;|***    newreq->request_hdr.rh_next   = 0L;
; Line 515
	*** 0009aa	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 0009ad	2b c0 			sub	ax,ax
	*** 0009af	26 89 47 0b 		mov	WORD PTR es:[bx+11],ax
	*** 0009b3	26 89 47 09 		mov	WORD PTR es:[bx+9],ax
;|***    newreq->funct_cat             = 0x80;
; Line 516
	*** 0009b7	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 0009ba	26 c6 47 0d 80 		mov	BYTE PTR es:[bx+13],128
;|***    newreq->funct_cod             = 0x54;
; Line 517
	*** 0009bf	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 0009c2	26 c6 47 0e 54 		mov	BYTE PTR es:[bx+14],84
;|***    newreq->pbuffer               = phys_to_gdt(pbuf_phys,2,gdt_selector[2]);
; Line 518
	*** 0009c7	ff 36 04 00 		push	WORD PTR _gdt_selector+4
	*** 0009cb	b8 02 00 		mov	ax,2
	*** 0009ce	50 			push	ax
	*** 0009cf	ff 76 fe 		push	WORD PTR [bp-2]
	*** 0009d2	ff 76 fc 		push	WORD PTR [bp-4]	;pbuf_phys
	*** 0009d5	9a 00 00 00 00 		call	FAR PTR _phys_to_gdt
	*** 0009da	83 c4 08 		add	sp,8
	*** 0009dd	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 0009e0	26 89 47 0f 		mov	WORD PTR es:[bx+15],ax
	*** 0009e4	26 89 57 11 		mov	WORD PTR es:[bx+17],dx
;|***    newreq->dbuffer.phys          = 0L;
; Line 519
	*** 0009e8	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 0009eb	2b c0 			sub	ax,ax
	*** 0009ed	26 89 47 15 		mov	WORD PTR es:[bx+21],ax
	*** 0009f1	26 89 47 13 		mov	WORD PTR es:[bx+19],ax
;|***    newreq->pbuf_len              = 2;
; Line 520
	*** 0009f5	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 0009f8	26 c7 47 19 02 00 	mov	WORD PTR es:[bx+25],2
;|***    newreq->dbuf_len              = 0;
; Line 521
	*** 0009fe	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 000a01	26 c7 47 1b 00 00 	mov	WORD PTR es:[bx+27],0
;|*** 
;|***    /* Change the File handle to the SCSI DD's handle */
;|***    newreq->file_number           = handle;
; Line 524
	*** 000a07	a1 00 00 		mov	ax,WORD PTR _handle
	*** 000a0a	c4 5e f8 		les	bx,DWORD PTR [bp-8]	;newreq
	*** 000a0d	26 89 47 17 		mov	WORD PTR es:[bx+23],ax
;|*** 
;|***    /* Store the device handle in the pbuffer */
;|***    pbuf = dhandle;
; Line 527
	*** 000a11	8b 46 06 		mov	ax,WORD PTR [bp+6]	;dhandle
	*** 000a14	89 46 ee 		mov	WORD PTR [bp-18],ax	;pbuf
;|*** 
;|***    /* Call the SCSI DD */
;|***    call_idc(idc_entry,(void *)newreq, scsi_idc.prot_DS);
; Line 530
	*** 000a17	ff 36 0a 00 		push	WORD PTR _scsi_idc+10
	*** 000a1b	ff 76 fa 		push	WORD PTR [bp-6]
	*** 000a1e	ff 76 f8 		push	WORD PTR [bp-8]	;newreq
	*** 000a21	ff 36 02 00 		push	WORD PTR _idc_entry+2
	*** 000a25	ff 36 00 00 		push	WORD PTR _idc_entry
	*** 000a29	9a 00 00 00 00 		call	FAR PTR _call_idc
	*** 000a2e	83 c4 0a 		add	sp,10
;|*** 
;|***    /* Return the request packet to the OS */
;|***    free_req(temp);
; Line 533
	*** 000a31	ff 76 f6 		push	WORD PTR [bp-10]
	*** 000a34	ff 76 f4 		push	WORD PTR [bp-12]	;temp
	*** 000a37	9a 00 00 00 00 		call	FAR PTR _free_req
	*** 000a3c	83 c4 04 		add	sp,4
;|*** 
;|***    /* Devdone the packet  */
;|***    return(0);
; Line 536
	*** 000a3f	b8 00 00 		mov	ax,0
	*** 000a42	e9 00 00 		jmp	$EX1336
;|*** 
;|*** }
; Line 538
					$EX1336:
	*** 000a45	5e 			pop	si
	*** 000a46	5f 			pop	di
	*** 000a47	8b e5 			mov	sp,bp
	*** 000a49	5d 			pop	bp
	*** 000a4a	cb 			ret	

_free_dhand	ENDP
MAINSEG	ENDS
END
